 Makefile.am                      |   2 +-
 apt-pkg/Makefile.am              |   6 +-
 apt-pkg/acquire-item.cc          |  69 +++--
 apt-pkg/acquire-item.h           |   3 +
 apt-pkg/acquire-method.cc        |   5 +
 apt-pkg/acquire-method.h         |   1 +
 apt-pkg/acquire-worker.cc        |   9 +-
 apt-pkg/acquire.cc               |   2 +
 apt-pkg/algorithms.cc            |  71 ++++-
 apt-pkg/algorithms.h             |   6 +-
 apt-pkg/cachefile.cc             |   4 +-
 apt-pkg/cacheiterators.h         |   3 +
 apt-pkg/clean.cc                 |   2 +
 apt-pkg/contrib/cdromutl.cc      |  18 ++
 apt-pkg/contrib/cmndline.cc      |  28 +-
 apt-pkg/contrib/cmndline.h       |   5 +
 apt-pkg/contrib/configuration.cc |   2 +
 apt-pkg/contrib/crc-16.cc        |   2 +
 apt-pkg/contrib/error.cc         |   5 +-
 apt-pkg/contrib/fileutl.cc       |   8 +-
 apt-pkg/contrib/hashes.cc        |   2 +
 apt-pkg/contrib/md5.cc           |   3 +-
 apt-pkg/contrib/md5.h            |   1 +
 apt-pkg/contrib/mmap.cc          |   3 +
 apt-pkg/contrib/progress.cc      |   3 +
 apt-pkg/contrib/sha1.cc          |   3 +-
 apt-pkg/contrib/sha1.h           |   1 +
 apt-pkg/contrib/strutl.cc        |   4 +-
 apt-pkg/contrib/strutl.h         |   1 +
 apt-pkg/contrib/system.h         |   2 +-
 apt-pkg/deb/debrecords.cc        |   8 +
 apt-pkg/deb/debrecords.h         |   1 +
 apt-pkg/deb/debsrcrecords.h      |   4 +
 apt-pkg/deb/debsystem.cc         |   2 +
 apt-pkg/depcache.cc              | 142 ++++++++--
 apt-pkg/depcache.h               |  15 +
 apt-pkg/indexfile.cc             |   3 +
 apt-pkg/init.cc                  |  57 ++--
 apt-pkg/luaiface.cc              |  62 ++---
 apt-pkg/luaiface.h               |  15 +-
 apt-pkg/orderlist.cc             |   6 +-
 apt-pkg/packagemanager.cc        |   4 +-
 apt-pkg/pkgcache.cc              | 102 ++++---
 apt-pkg/pkgcache.h               |  37 ++-
 apt-pkg/pkgcachegen.cc           |  36 ++-
 apt-pkg/pkgcachegen.h            |   3 +-
 apt-pkg/pkgrecords.cc            |   6 +-
 apt-pkg/pkgrecords.h             |   1 +
 apt-pkg/pkgsystem.cc             |   3 +
 apt-pkg/pkgsystem.h              |   2 +-
 apt-pkg/policy.cc                |  55 +++-
 apt-pkg/policy.h                 |   1 +
 apt-pkg/repository.cc            |   2 +
 apt-pkg/repository.h             |   2 +-
 apt-pkg/rpm/rpmhandler.cc        |   4 +-
 apt-pkg/rpm/rpmhandler.h         |   6 +-
 apt-pkg/rpm/rpmlistparser.cc     |  26 +-
 apt-pkg/rpm/rpmlistparser.h      |   1 +
 apt-pkg/rpm/rpmmisc.h            |   1 +
 apt-pkg/rpm/rpmpackagedata.cc    |   3 +-
 apt-pkg/rpm/rpmpackagedata.h     |   3 +-
 apt-pkg/rpm/rpmpm.cc             | 156 +++++++----
 apt-pkg/rpm/rpmrecords.cc        |  76 ++++--
 apt-pkg/rpm/rpmrecords.h         |   1 +
 apt-pkg/rpm/rpmsrcrecords.cc     |  92 +++++--
 apt-pkg/rpm/rpmsrcrecords.h      |  13 +-
 apt-pkg/rpm/rpmsystem.cc         |  73 +++--
 apt-pkg/rpm/rpmsystem.h          |   2 +-
 apt-pkg/rpm/rpmversion.cc        |   9 +
 apt-pkg/sourcelist.cc            |  51 ++--
 apt-pkg/sourcelist.h             |   6 +-
 apt-pkg/srcrecords.cc            |   8 +-
 apt-pkg/srcrecords.h             |   3 +
 apt-pkg/tagfile.cc               |   2 +
 apt-pkg/version.cc               |   2 +
 apt-pkg/versionmatch.cc          |  33 ++-
 apt-pkg/versionmatch.h           |   2 +
 buildlib/archtable               |   8 +-
 buildlib/tools.m4                |  17 +-
 cmdline/Makefile.am              |   7 +-
 cmdline/Makefile.in              |   2 +-
 cmdline/acqprogress.cc           |   9 +-
 cmdline/apt-cache.cc             |  15 +-
 cmdline/apt-cdrom.cc             |  42 +--
 cmdline/apt-config.cc            |   7 +-
 cmdline/apt-get.cc               | 340 ++++++++++++++++++-----
 cmdline/apt-pipe.c               | 389 ++++++++++++++++++++++++++
 cmdline/apt-shell.cc             | 294 +++++++++++++++++---
 cmdline/indexcopy.cc             |   2 +
 cmdline/rpmindexcopy.cc          |   2 +
 configure.in                     |  28 +-
 contrib/apt-wrapper/apt          |   2 +-
 contrib/apt-wrapper/apt.1        |   4 +-
 doc/apt.ent                      |   4 +-
 methods/Makefile.am              |   3 +-
 methods/cdrom.cc                 |  14 +-
 methods/connect.cc               |   2 +
 methods/copy.cc                  |   2 +
 methods/file.cc                  |   2 +
 methods/ftp.cc                   |   4 +-
 methods/gpg.cc                   |  16 +-
 methods/gzip.cc                  |   2 +
 methods/http.cc                  |   2 +
 methods/rfc2553emu.cc            |   2 +
 methods/rsh.cc                   |   2 +
 methods/rsync-method.h           | 116 ++++++++
 methods/rsync.cc                 | 572 +++++++++++++++++++++++++++++++++++++++
 po/de_DE.po                      |   4 +-
 po/es_ES.po                      |   2 +-
 po/it_IT.po                      |   2 +-
 po/ja.po                         |   2 +-
 po/pt_BR.po                      |   6 +-
 po/ru.po                         |  11 +-
 test/conf.cc                     |   3 +
 test/extract-control.cc          |   3 +
 test/hash.cc                     |   3 +
 test/mthdcat.cc                  |   2 +
 test/rpmver.cc                   |   3 +
 test/scratch.cc                  |   3 +
 test/testdeb.cc                  |   3 +
 test/testextract.cc              |   3 +
 test/uri.cc                      |   2 +
 test/versiontest.cc              |   2 +
 tools/cached_md5.cc              |   5 +-
 tools/countpkglist.cc            |   3 +
 tools/genpkglist.cc              | 326 +++++++++++++++-------
 tools/gensrclist.cc              |   5 +-
 127 files changed, 3067 insertions(+), 653 deletions(-)

diff --git a/Makefile.am b/Makefile.am
index 415e0b5..d410113 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = buildlib intl lua apt-pkg methods cmdline tools doc m4 po
+SUBDIRS = buildlib apt-pkg methods cmdline tools doc m4 po
 
 ACLOCAL_AMFLAGS = -I m4 -I buildlib
 
diff --git a/apt-pkg/Makefile.am b/apt-pkg/Makefile.am
index ebf0398..82b952c 100644
--- a/apt-pkg/Makefile.am
+++ b/apt-pkg/Makefile.am
@@ -2,14 +2,12 @@
 lib_LTLIBRARIES = libapt-pkg.la
 
 libapt_pkg_la_LIBADD = @RPMLIBS@
-libapt_pkg_la_LDFLAGS = -version-info 2:0:0 -release @GLIBC_VER@-@LIBSTDCPP_VER@
+libapt_pkg_la_LDFLAGS = -version-info 6:0:1 -release @GLIBC_VER@-@LIBSTDCPP_VER@@FILE_OFFSET_BITS_SUFFIX@
 
 AM_CPPFLAGS = -DLIBDIR=\"$(libdir)\"
 
-INCLUDES = -I$(top_srcdir)/lua/include -I$(top_srcdir)/lua/local
-
 if WITH_LUA
-libapt_pkg_la_LIBADD += $(top_builddir)/lua/liblua.la
+libapt_pkg_la_LIBADD += -llua
 endif
 
 libapt_pkg_la_SOURCES = \
diff --git a/apt-pkg/acquire-item.cc b/apt-pkg/acquire-item.cc
index 15ea22d..e9ba315 100644
--- a/apt-pkg/acquire-item.cc
+++ b/apt-pkg/acquire-item.cc
@@ -16,6 +16,9 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/acquire-item.h"
 #endif
+
+#include <config.h>
+
 #include <apt-pkg/acquire-item.h>
 #include <apt-pkg/configuration.h>
 #include <apt-pkg/sourcelist.h>
@@ -26,7 +29,6 @@
 // CNC:2002-07-03
 #include <apt-pkg/repository.h>
 #include <apt-pkg/md5.h>
-#include <config.h>
 #include <apt-pkg/luaiface.h>
 #include <iostream>
 #include <assert.h>
@@ -38,6 +40,7 @@ using namespace std;
 #include <unistd.h>
 #include <errno.h>
 #include <string>
+#include <sstream>
 #include <stdio.h>
 									/*}}}*/
 
@@ -48,7 +51,7 @@ using std::string;
 // ---------------------------------------------------------------------
 /* Returns false only if the checksums fail (the file not existing is not
    a checksum mismatch) */
-bool VerifyChecksums(string File,unsigned long Size,string MD5)
+static bool VerifyChecksums(string File, unsigned long Size, string MD5)
 {
    struct stat Buf;
    
@@ -191,7 +194,7 @@ pkgAcqIndex::pkgAcqIndex(pkgAcquire *Owner,pkgRepository *Repository,
 
    // Create the item
    // CNC:2002-07-03
-   Desc.URI = URI + _config->Find("Acquire::ComprExtension", ".bz2");
+   Desc.URI = URI + ".bz2";
    Desc.Description = URIDesc;
    Desc.Owner = this;
    Desc.ShortDesc = ShortDesc;
@@ -227,6 +230,9 @@ pkgAcqIndex::pkgAcqIndex(pkgAcquire *Owner,pkgRepository *Repository,
 	    unlink(FinalFile.c_str());
 	    unlink(DestFile.c_str());
 	 }
+
+	 if (Repository->FindChecksums(RealURI + ".xz", Size, MD5Hash) == true)
+	    Desc.URI = URI + ".xz";
       }
       else if (Repository->IsAuthenticated() == true)
       {
@@ -283,7 +289,7 @@ void pkgAcqIndex::Done(string Message,unsigned long Size,string MD5,
 	    ErrorText = _("Size mismatch");
 	    Rename(DestFile,DestFile + ".FAILED");
 	    if (_config->FindB("Acquire::Verbose",false) == true) 
-	       _error->Warning("Size mismatch of index file %s: %ul was supposed to be %ul",
+	       _error->Warning("Size mismatch of index file %s: %lu was supposed to be %lu",
 			       RealURI.c_str(), Size, FSize);
 	    return;
 	 }
@@ -360,11 +366,15 @@ void pkgAcqIndex::Done(string Message,unsigned long Size,string MD5,
    
    Decompression = true;
    DestFile += ".decomp";
+
    // CNC:2002-07-03
-   Desc.URI = "bzip2:" + FileName;
+   const char *prog = "bzip2";
+   if (flExtension(Desc.URI) == "xz")
+      prog = "xz";
+   Desc.URI = string(prog) + ":" + FileName;
    QueueURI(Desc);
    // CNC:2002-07-03
-   Mode = "bzip2";
+   Mode = prog;
 }
 									/*}}}*/
 
@@ -476,14 +486,29 @@ void pkgAcqIndexRel::Done(string Message,unsigned long Size,string MD5,
 	    return;
 	 }
 
-	 // Match fingerprint of Release file
-	 if (Repository->FingerPrint != FingerPrint)
-	 {
-	    Status = StatError;
-	    ErrorText = _("Signature fingerprint of Release file does not match (expected ")
-	       +Repository->FingerPrint+_(", got ")+FingerPrint+")";
-	    return;
-	 }
+ 	 bool found = false;
+ 	 for (vector<string>::const_iterator I = Repository->FingerPrint.begin();
+ 	      I != Repository->FingerPrint.end(); I++)
+ 	 {
+ 	    // Match fingerprint of Release file
+ 	    if ((*I) == FingerPrint)
+ 	    {
+ 	       found = true;
+ 	       break;
+ 	    }
+ 	 }
+ 
+ 	 if (!found)
+ 	 {
+ 	    Status = StatError;
+ 	    ErrorText = _("Signature fingerprint of Release file does not match (expected ");
+ 	    for (vector<string>::const_iterator I = Repository->FingerPrint.begin();
+ 		 I != Repository->FingerPrint.end(); I++)
+ 	      ErrorText += "\n"+(*I);
+ 	    ErrorText += _(", got ")+FingerPrint+")";
+  	    return;
+  	 }
+
       }
 
       // Done, move it into position
@@ -559,7 +584,7 @@ void pkgAcqIndexRel::Done(string Message,unsigned long Size,string MD5,
 	 ErrorText = _("Size mismatch");
 	 Rename(DestFile,DestFile + ".FAILED");
 	 if (_config->FindB("Acquire::Verbose",false) == true) 
-	    _error->Warning("Size mismatch of index file %s: %ul was supposed to be %ul",
+	    _error->Warning("Size mismatch of index file %s: %lu was supposed to be %lu",
 			    RealURI.c_str(), Size, FSize);
 	 return;
       }
@@ -667,9 +692,13 @@ pkgAcqArchive::pkgAcqArchive(pkgAcquire *Owner,pkgSourceList *Sources,
 	 return;
             
       // Generate the final file name as: package_version_arch.foo
+      std::ostringstream BTss;
+      BTss << Version.BTime();
+
       StoreFilename = QuoteString(Version.ParentPkg().Name(),"_:") + '_' +
 	              QuoteString(Version.VerStr(),"_:") + '_' +
-     	              QuoteString(Version.Arch(),"_:.") + 
+     	              QuoteString(Version.Arch(),"_:.") + '_' +
+		      QuoteString(BTss.str(),"_") +
 	              "." + flExtension(Parse.FileName());
    }
       
@@ -824,7 +853,10 @@ void pkgAcqArchive::Done(string Message,unsigned long Size,string Md5Hash,
    {
       if (Md5Hash != MD5)
       {
-	 Status = StatError;
+	if (_config->FindB("Debug::pkgAcquire::Auth", false)) {
+	    cerr << "md5 mismatch: " << Md5Hash << "!=" << MD5 << endl;
+	}
+ 	 Status = StatError;
 	 ErrorText = _("MD5Sum mismatch");
 	 Rename(DestFile,DestFile + ".FAILED");
 	 return;
@@ -968,6 +1000,9 @@ void pkgAcqFile::Done(string Message,unsigned long Size,string MD5,
    {
       if (Md5Hash != MD5)
       {
+	if (_config->FindB("Debug::pkgAcquire::Auth", false)) {
+	    cerr << "md5 mismatch: " << Md5Hash << "!=" << MD5 << endl;
+	}
 	 Status = StatError;
 	 ErrorText = "MD5Sum mismatch";
 	 Rename(DestFile,DestFile + ".FAILED");
diff --git a/apt-pkg/acquire-item.h b/apt-pkg/acquire-item.h
index 4303648..988e4dd 100644
--- a/apt-pkg/acquire-item.h
+++ b/apt-pkg/acquire-item.h
@@ -61,6 +61,9 @@ class pkgAcquire::Item
    
    // File to write the fetch into
    string DestFile;
+   // Alternative temporary destination
+   // Used if method (e.g. rsync) can't use directly DestFile
+   string TmpFile;
 
    // Action members invoked by the worker
    virtual void Failed(string Message,pkgAcquire::MethodConfig *Cnf);
diff --git a/apt-pkg/acquire-method.cc b/apt-pkg/acquire-method.cc
index 1f2783a..a1734b3 100644
--- a/apt-pkg/acquire-method.cc
+++ b/apt-pkg/acquire-method.cc
@@ -18,6 +18,8 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/acquire-method.h"
 #endif
+#include <config.h>
+
 #include <apt-pkg/acquire-method.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/configuration.h>
@@ -152,6 +154,9 @@ void pkgAcqMethod::URIStart(FetchResult &Res)
    if (Res.ResumePoint != 0)
       s << "Resume-Point: " << Res.ResumePoint << "\n";
 
+   if (Res.TmpFilename.size() != 0)
+      s << "Tmp-Filename: " << Res.TmpFilename << "\n";
+
    s << "\n";
    string S = s.str();
    if (write(STDOUT_FILENO,S.c_str(),S.size()) != (ssize_t)S.size())
diff --git a/apt-pkg/acquire-method.h b/apt-pkg/acquire-method.h
index dcca197..a197128 100644
--- a/apt-pkg/acquire-method.h
+++ b/apt-pkg/acquire-method.h
@@ -47,6 +47,7 @@ class pkgAcqMethod
       time_t LastModified;
       bool IMSHit;
       string Filename;
+      string TmpFilename;
       unsigned long Size;
       unsigned long ResumePoint;
       
diff --git a/apt-pkg/acquire-worker.cc b/apt-pkg/acquire-worker.cc
index c2673a7..541df8e 100644
--- a/apt-pkg/acquire-worker.cc
+++ b/apt-pkg/acquire-worker.cc
@@ -15,6 +15,8 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/acquire-worker.h"
 #endif
+#include <config.h>
+
 #include <apt-pkg/acquire-worker.h>
 #include <apt-pkg/acquire-item.h>
 #include <apt-pkg/configuration.h>
@@ -269,6 +271,7 @@ bool pkgAcquire::Worker::RunMessages()
 	    CurrentSize = 0;
 	    TotalSize = atoi(LookupTag(Message,"Size","0").c_str());
 	    ResumePoint = atoi(LookupTag(Message,"Resume-Point","0").c_str());
+	    Itm->Owner->TmpFile = LookupTag(Message,"Tmp-Filename");
 	    Itm->Owner->Start(Message,atoi(LookupTag(Message,"Size","0").c_str()));
 
 	    // Display update before completion
@@ -597,7 +600,11 @@ void pkgAcquire::Worker::Pulse()
       return;
  
    struct stat Buf;
-   if (stat(CurrentItem->Owner->DestFile.c_str(),&Buf) != 0)
+   int res = 1;
+   if (CurrentItem->Owner->TmpFile.empty()==false)
+      res = stat(CurrentItem->Owner->TmpFile.c_str(),&Buf);
+
+   if (res!=0 && stat(CurrentItem->Owner->DestFile.c_str(),&Buf) != 0)
       return;
    CurrentSize = Buf.st_size;
    
diff --git a/apt-pkg/acquire.cc b/apt-pkg/acquire.cc
index 233247a..7f694db 100644
--- a/apt-pkg/acquire.cc
+++ b/apt-pkg/acquire.cc
@@ -16,6 +16,8 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/acquire.h"
 #endif       
+#include <config.h>
+
 #include <apt-pkg/acquire.h>
 #include <apt-pkg/acquire-item.h>
 #include <apt-pkg/acquire-worker.h>
diff --git a/apt-pkg/algorithms.cc b/apt-pkg/algorithms.cc
index e8abff2..ce532c1 100644
--- a/apt-pkg/algorithms.cc
+++ b/apt-pkg/algorithms.cc
@@ -17,6 +17,8 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/algorithms.h"
 #endif 
+#include <config.h>
+
 #include <apt-pkg/algorithms.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/configuration.h>
@@ -335,6 +337,32 @@ bool pkgFixBroken(pkgDepCache &Cache)
  */
 bool pkgDistUpgrade(pkgDepCache &Cache)
 {
+   /* Upgrade all installed packages first without autoinst to help the resolver
+      in versioned or-groups to upgrade the old solver instead of installing
+      a new one (if the old solver is not the first one [anymore]) */
+   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
+      // ALT:2014-06-25
+      if (I->CurrentVer != 0)
+      {
+	 // Was it obsoleted?
+	 bool Obsoleted = false;
+	 for (pkgCache::DepIterator D = I.RevDependsList(); D.end() == false; D++)
+	 {
+	    if (D->Type == pkgCache::Dep::Obsoletes &&
+	        Cache[D.ParentPkg()].CandidateVer != 0 &&
+		Cache[D.ParentPkg()].CandidateVerIter(Cache).Downloadable() == true &&
+	        (pkgCache::Version*)D.ParentVer() == Cache[D.ParentPkg()].CandidateVer &&
+	        Cache.VS().CheckDep(I.CurrentVer().VerStr(), D) == true &&
+		Cache.GetPkgPriority(D.ParentPkg()) >= Cache.GetPkgPriority(I))
+	    {
+	       Obsoleted = true;
+	       break;
+	    }
+	 }
+	 if (Obsoleted == false)
+	    Cache.MarkInstall(I,false);
+      }
+
    /* Auto upgrade all installed packages, this provides the basis 
       for the installation */
    for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; I++)
@@ -540,6 +568,9 @@ int pkgProblemResolver::ScoreSort(const void *a,const void *b)
 // ProblemResolver::MakeScores - Make the score table			/*{{{*/
 // ---------------------------------------------------------------------
 /* */
+
+#include "rpm/rpmpackagedata.h"
+
 void pkgProblemResolver::MakeScores()
 {
    unsigned long Size = Cache.Head().PackageCount;
@@ -623,13 +654,28 @@ void pkgProblemResolver::MakeScores()
 
    /* Protected things are pushed really high up. This number should put them
       ahead of everything */
+   RPMPackageData *rpmdata = new RPMPackageData();
    for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; I++)
    {
       if ((Flags[I->ID] & Protected) != 0)
 	 Scores[I->ID] += 10000;
       if ((I->Flags & pkgCache::Flag::Essential) == pkgCache::Flag::Essential)
 	 Scores[I->ID] += 5000;
+      pkgCache::State::VerPriority p = rpmdata->VerPriority(I.Name());
+      switch (p) {
+         case pkgCache::State::Important:
+	   Scores[I->ID] += 1000;
+	 case pkgCache::State::Required:
+	   Scores[I->ID] += 1000;
+	 case pkgCache::State::Standard:
+	   Scores[I->ID] += 1000;
+	 case pkgCache::State::Optional:
+	 case pkgCache::State::Extra:
+	 default:
+	   break;
+      }
    }   
+   This = this;
 }
 									/*}}}*/
 // ProblemResolver::DoUpgrade - Attempt to upgrade this package		/*{{{*/
@@ -1402,6 +1448,27 @@ bool pkgProblemResolver::RemoveDepends()
    return true;
 }
 									/*}}}*/
+/* Like strcmp, but compares digit sections by number value.
+ * E.g.: tar-1.10 > tar-1.9 > tar-1.1a
+ * (while strcmp gives tar-1.10 < tar-1.9). */
+static int nameCompare(const char* n1, const char* n2)
+{
+   while(*n1 && *n2) {
+      if(isdigit(*n1) && isdigit(*n2)) {
+	 unsigned long long i1, i2;
+	 i1 = strtoull(n1, const_cast<char **>(&n1), 10);
+	 i2 = strtoull(n2, const_cast<char **>(&n2), 10);
+	 if(i1 != i2)
+	    return (i1 > i2) ? 1 : -1;
+      } else if(*n1 != *n2) {
+	 return (*n1 > *n2) ? 1 : -1;
+      } else {
+	 n1++;
+	 n2++;
+      }
+   }
+   return 0;
+}
 
 // PrioSortList - Sort a list of versions by priority			/*{{{*/
 // ---------------------------------------------------------------------
@@ -1423,7 +1490,9 @@ static int PrioComp(const void *A,const void *B)
    
    if (L->Priority != R->Priority)
       return L->Priority - R->Priority;
-   return strcmp(L.ParentPkg().Name(),R.ParentPkg().Name());
+   // PrioComp("gcc2","gcc3") == 1
+   // PrioComp("gcc2", gcc10") == 1
+   return nameCompare(R.ParentPkg().Name(),L.ParentPkg().Name());
 }
 void pkgPrioSortList(pkgCache &Cache,pkgCache::Version **List)
 {
diff --git a/apt-pkg/algorithms.h b/apt-pkg/algorithms.h
index 1b510e2..2117f77 100644
--- a/apt-pkg/algorithms.h
+++ b/apt-pkg/algorithms.h
@@ -96,7 +96,6 @@ class pkgProblemResolver
    
    // Sort stuff
    static pkgProblemResolver *This;
-   static int ScoreSort(const void *a,const void *b);
 
    struct PackageKill
    {
@@ -104,7 +103,6 @@ class pkgProblemResolver
       DepIterator Dep;
    };
 
-   void MakeScores();
    bool DoUpgrade(pkgCache::PkgIterator Pkg);
    
    public:
@@ -125,6 +123,10 @@ class pkgProblemResolver
    
    pkgProblemResolver(pkgDepCache *Cache);
    ~pkgProblemResolver();
+
+   // Sort stuff
+   static int ScoreSort(const void *a,const void *b);
+   void MakeScores();
 };
 
 bool pkgDistUpgrade(pkgDepCache &Cache);
diff --git a/apt-pkg/cachefile.cc b/apt-pkg/cachefile.cc
index 217c503..48ab404 100644
--- a/apt-pkg/cachefile.cc
+++ b/apt-pkg/cachefile.cc
@@ -16,6 +16,8 @@
 #pragma implementation "apt-pkg/cachefile.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/cachefile.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/sourcelist.h>
@@ -98,7 +100,7 @@ bool pkgCacheFile::Open(OpProgress &Progress,bool WithLock)
    Policy = new pkgPolicy(Cache);
    if (_error->PendingError() == true)
       return false;
-   if (ReadPinFile(*Policy) == false)
+   if (ReadPinFile(*Policy) == false || ReadPinDir(*Policy) == false)
       return false;
    
    // Create the dependency cache
diff --git a/apt-pkg/cacheiterators.h b/apt-pkg/cacheiterators.h
index 92427b8..bf91ef0 100644
--- a/apt-pkg/cacheiterators.h
+++ b/apt-pkg/cacheiterators.h
@@ -126,6 +126,7 @@ class pkgCache::VerIterator
    inline pkgCache *Cache() {return Owner;};
       
    inline const char *VerStr() const {return Ver->VerStr == 0?0:Owner->StrP + Ver->VerStr;};
+   inline const int BTime() const {return Ver->BTime;};
    inline const char *Section() const {return Ver->Section == 0?0:Owner->StrP + Ver->Section;};
    inline const char *Arch() const {return Ver->Arch == 0?0:Owner->StrP + Ver->Arch;};
    inline PkgIterator ParentPkg() const {return PkgIterator(*Owner,Owner->PkgP + Ver->ParentPkg);};
@@ -258,6 +259,8 @@ class pkgCache::PrvIterator
    inline PkgIterator OwnerPkg() {return PkgIterator(*Owner,Owner->PkgP + Owner->VerP[Prv->Version].ParentPkg);};
    inline unsigned long Index() const {return Prv - Owner->ProvideP;};
 
+   inline PrvIterator() : Prv(0), Type(PrvVer), Owner(0)  {};
+
    inline PrvIterator(pkgCache &Owner,Provides *Trg,Version *) :
           Prv(Trg), Type(PrvVer), Owner(&Owner) 
    {
diff --git a/apt-pkg/clean.cc b/apt-pkg/clean.cc
index 7d33f77..e3bacf4 100644
--- a/apt-pkg/clean.cc
+++ b/apt-pkg/clean.cc
@@ -12,6 +12,8 @@
 #pragma implementation "apt-pkg/clean.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/clean.h>
 #include <apt-pkg/strutl.h>
 #include <apt-pkg/error.h>
diff --git a/apt-pkg/contrib/cdromutl.cc b/apt-pkg/contrib/cdromutl.cc
index 61fcfcf..91777e9 100644
--- a/apt-pkg/contrib/cdromutl.cc
+++ b/apt-pkg/contrib/cdromutl.cc
@@ -34,6 +34,8 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <stdio.h>
+#include <mntent.h>
+#include <cstdlib>
 									/*}}}*/
 
 // IsMounted - Returns true if the mount point is mounted		/*{{{*/
@@ -100,6 +102,22 @@ bool UnmountCdrom(string Path)
       }
       else
       {
+        FILE *f;
+        if ((f = setmntent ("/proc/mounts", "r")) != NULL)
+        {
+          struct mntent *mnt;
+          while ((mnt = getmntent (f)) != NULL)
+	  {
+	    string MntDir(mnt->mnt_dir);
+	    if (MntDir[MntDir.length() - 1] != '/')
+	      MntDir += '/';
+            if ( Path == MntDir )
+              if ((strcmp ("subfs", mnt->mnt_type) == 0) || (strcmp ("supermount", mnt->mnt_type) == 0))
+                _exit(0);
+	  }
+          endmntent (f);
+        }
+
 	 const char *Args[10];
 	 Args[0] = "umount";
 	 Args[1] = Path.c_str();
diff --git a/apt-pkg/contrib/cmndline.cc b/apt-pkg/contrib/cmndline.cc
index 2b3d7dc..03a0a3d 100644
--- a/apt-pkg/contrib/cmndline.cc
+++ b/apt-pkg/contrib/cmndline.cc
@@ -14,14 +14,30 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/cmndline.h"
 #endif
+#include <config.h>
+
 #include <apt-pkg/cmndline.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/strutl.h>
 
 #include <apti18n.h>    
+
+#include <memory>
 									/*}}}*/
 using namespace std;
 
+void CommandLine::FreeFileList()
+{
+  if (FileList)
+  {
+    for (const char **I=FileList; *I; ++I)
+      free(const_cast<char *>(*I));
+
+    delete [] FileList;
+    FileList = 0;
+  }
+}
+
 // CommandLine::CommandLine - Constructor				/*{{{*/
 // ---------------------------------------------------------------------
 /* */
@@ -35,7 +51,7 @@ CommandLine::CommandLine(Args *AList,Configuration *Conf) : ArgList(AList),
 /* */
 CommandLine::~CommandLine()
 {
-   delete [] FileList;
+   FreeFileList();
 }
 									/*}}}*/
 // CommandLine::Parse - Main action member				/*{{{*/
@@ -43,8 +59,11 @@ CommandLine::~CommandLine()
 /* */
 bool CommandLine::Parse(int argc,const char **argv)
 {
-   delete [] FileList;
+   FreeFileList();
    FileList = new const char *[argc];
+   std::uninitialized_fill(const_cast<char**>(FileList),
+                           const_cast<char**>(FileList+argc),
+			   static_cast<char*>(0));
    const char **Files = FileList;
    int I;
    for (I = 1; I != argc; I++)
@@ -54,7 +73,7 @@ bool CommandLine::Parse(int argc,const char **argv)
       // It is not an option
       if (*Opt != '-')
       {
-	 *Files++ = Opt;
+	 *Files++ = strdup(Opt);
 	 continue;
       }
       
@@ -136,7 +155,7 @@ bool CommandLine::Parse(int argc,const char **argv)
    
    // Copy any remaining file names over
    for (; I != argc; I++)
-      *Files++ = argv[I];
+      *Files++ = strdup(argv[I]);
    *Files = 0;
    
    return true;
@@ -333,6 +352,7 @@ unsigned int CommandLine::FileSize() const
 bool CommandLine::DispatchArg(Dispatch *Map,bool NoMatch)
 {
    int I;
+   if (FileSize() == 0) return false;
    for (I = 0; Map[I].Match != 0; I++)
    {
       if (strcmp(FileList[0],Map[I].Match) == 0)
diff --git a/apt-pkg/contrib/cmndline.h b/apt-pkg/contrib/cmndline.h
index a77b010..5d8a512 100644
--- a/apt-pkg/contrib/cmndline.h
+++ b/apt-pkg/contrib/cmndline.h
@@ -52,6 +52,10 @@
 
 class CommandLine
 {
+   CommandLine(const CommandLine& other);
+   CommandLine& operator=(const CommandLine& other);
+
+
    public:
    struct Args;
    struct Dispatch;
@@ -84,6 +88,7 @@ class CommandLine
       
    CommandLine(Args *AList,Configuration *Conf);
    ~CommandLine();
+   void FreeFileList();
 };
 
 struct CommandLine::Args
diff --git a/apt-pkg/contrib/configuration.cc b/apt-pkg/contrib/configuration.cc
index 6a69080..162765a 100644
--- a/apt-pkg/contrib/configuration.cc
+++ b/apt-pkg/contrib/configuration.cc
@@ -18,6 +18,8 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/configuration.h"
 #endif
+#include <config.h>
+
 #include <apt-pkg/configuration.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/strutl.h>
diff --git a/apt-pkg/contrib/crc-16.cc b/apt-pkg/contrib/crc-16.cc
index 6cd641b..8c56793 100644
--- a/apt-pkg/contrib/crc-16.cc
+++ b/apt-pkg/contrib/crc-16.cc
@@ -19,6 +19,8 @@
 #pragma implementation "apt-pkg/crc-16.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/crc-16.h>
 									/*}}}*/
 
diff --git a/apt-pkg/contrib/error.cc b/apt-pkg/contrib/error.cc
index 8110a56..e012090 100644
--- a/apt-pkg/contrib/error.cc
+++ b/apt-pkg/contrib/error.cc
@@ -18,6 +18,8 @@
 #pragma implementation "apt-pkg/error.h"
 #endif 
 
+#include "config.h"
+   									/*}}}*/
 #include <apt-pkg/error.h>
 
 #include <iostream>
@@ -26,9 +28,8 @@
 #include <string>
 #include <stdarg.h>
 #include <unistd.h>
+#include <cstring>
 
-#include "config.h"
-   									/*}}}*/
 
 using namespace std;
 
diff --git a/apt-pkg/contrib/fileutl.cc b/apt-pkg/contrib/fileutl.cc
index 400ac67..58d2e74 100644
--- a/apt-pkg/contrib/fileutl.cc
+++ b/apt-pkg/contrib/fileutl.cc
@@ -17,6 +17,8 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/fileutl.h"
 #endif 
+#include <config.h>
+
 #include <apt-pkg/fileutl.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/sptr.h>
@@ -30,6 +32,8 @@
 #include <sys/wait.h>
 #include <signal.h>
 #include <errno.h>
+#include <cstdlib>
+#include <cstring>
 
 // CNC:2003-02-14 - Ralf Corsepius told RH8 with GCC 3.2.1 fails
 //                  compiling without moving this header to here.
@@ -169,14 +173,14 @@ string flNotFile(string File)
    return string(File,0,Res);
 }
 									/*}}}*/
-// flExtension - Return the extension for the file			/*{{{*/
+// flExtension - Return the extension for the file or "" if none	/*{{{*/
 // ---------------------------------------------------------------------
 /* */
 string flExtension(string File)
 {
    string::size_type Res = File.rfind('.');
    if (Res == string::npos)
-      return File;
+      return string();
    Res++;
    return string(File,Res,Res - File.length());
 }
diff --git a/apt-pkg/contrib/hashes.cc b/apt-pkg/contrib/hashes.cc
index 6a11c42..ab26b9a 100644
--- a/apt-pkg/contrib/hashes.cc
+++ b/apt-pkg/contrib/hashes.cc
@@ -15,6 +15,8 @@
 #pragma implementation "apt-pkg/hashes.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/hashes.h>
     
 #include <unistd.h>    
diff --git a/apt-pkg/contrib/md5.cc b/apt-pkg/contrib/md5.cc
index 029e336..0461971 100644
--- a/apt-pkg/contrib/md5.cc
+++ b/apt-pkg/contrib/md5.cc
@@ -39,6 +39,8 @@
 #pragma implementation "apt-pkg/md5.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/md5.h>
 #include <apt-pkg/strutl.h>
 
@@ -46,7 +48,6 @@
 #include <unistd.h>
 #include <netinet/in.h>                          // For htonl
 #include <inttypes.h>
-#include <config.h>
 #include <system.h>
 									/*}}}*/
 
diff --git a/apt-pkg/contrib/md5.h b/apt-pkg/contrib/md5.h
index 5895966..6e6b13b 100644
--- a/apt-pkg/contrib/md5.h
+++ b/apt-pkg/contrib/md5.h
@@ -28,6 +28,7 @@
 #endif 
 
 #include <string>
+#include <cstring>
 
 using std::string;
 
diff --git a/apt-pkg/contrib/mmap.cc b/apt-pkg/contrib/mmap.cc
index ed3cd78..86b4b82 100644
--- a/apt-pkg/contrib/mmap.cc
+++ b/apt-pkg/contrib/mmap.cc
@@ -25,6 +25,8 @@
 #pragma implementation "apt-pkg/mmap.h"
 #endif 
 
+#include <config.h>
+
 #define _BSD_SOURCE
 #include <apt-pkg/mmap.h>
 #include <apt-pkg/error.h>
@@ -35,6 +37,7 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <fcntl.h>
+#include <cstring>
    									/*}}}*/
 
 // MMap::MMap - Constructor						/*{{{*/
diff --git a/apt-pkg/contrib/progress.cc b/apt-pkg/contrib/progress.cc
index 0027ffc..b6ba654 100644
--- a/apt-pkg/contrib/progress.cc
+++ b/apt-pkg/contrib/progress.cc
@@ -11,6 +11,8 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/progress.h"
 #endif 
+#include <config.h>
+
 #include <apt-pkg/progress.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/configuration.h>
@@ -19,6 +21,7 @@
 
 #include <iostream>
 #include <stdio.h>
+#include <cstring>
 									/*}}}*/
 
 using namespace std;
diff --git a/apt-pkg/contrib/sha1.cc b/apt-pkg/contrib/sha1.cc
index 7934a47..e9a0d88 100644
--- a/apt-pkg/contrib/sha1.cc
+++ b/apt-pkg/contrib/sha1.cc
@@ -33,13 +33,14 @@
 #pragma implementation "apt-pkg/sha1.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/sha1.h>
 #include <apt-pkg/strutl.h>
 
 #include <string.h>
 #include <unistd.h>
 #include <inttypes.h>
-#include <config.h>
 #include <system.h>
 									/*}}}*/
 
diff --git a/apt-pkg/contrib/sha1.h b/apt-pkg/contrib/sha1.h
index fb2c7df..00d8d52 100644
--- a/apt-pkg/contrib/sha1.h
+++ b/apt-pkg/contrib/sha1.h
@@ -19,6 +19,7 @@
 #endif 
 
 #include <string>
+#include <cstring>
 
 using std::string;
 
diff --git a/apt-pkg/contrib/strutl.cc b/apt-pkg/contrib/strutl.cc
index a75fbdf..91932e9 100644
--- a/apt-pkg/contrib/strutl.cc
+++ b/apt-pkg/contrib/strutl.cc
@@ -19,6 +19,8 @@
 #pragma implementation "apt-pkg/strutl.h"
 #endif
 
+#include "config.h"
+
 #include <apt-pkg/strutl.h>
 #include <apt-pkg/fileutl.h>
 #include <apt-pkg/error.h>
@@ -33,8 +35,6 @@
 #include <errno.h>
 #include <stdarg.h>
 
-#include "config.h"
-
 using namespace std;
 									/*}}}*/
 
diff --git a/apt-pkg/contrib/strutl.h b/apt-pkg/contrib/strutl.h
index 353e78a..76584c2 100644
--- a/apt-pkg/contrib/strutl.h
+++ b/apt-pkg/contrib/strutl.h
@@ -25,6 +25,7 @@
 #include <vector>
 #include <iostream>
 #include <time.h>
+#include <cstring>
 
 using std::string;
 using std::vector;
diff --git a/apt-pkg/contrib/system.h b/apt-pkg/contrib/system.h
index 7528671..ea02653 100644
--- a/apt-pkg/contrib/system.h
+++ b/apt-pkg/contrib/system.h
@@ -26,7 +26,7 @@
 #endif
 
 // GNU C++ has a min/max operator <coolio>
-#if defined(__GNUG__)
+#if 0
 #define MIN(A,B) ((A) <? (B))
 #define MAX(A,B) ((A) >? (B))
 #endif
diff --git a/apt-pkg/deb/debrecords.cc b/apt-pkg/deb/debrecords.cc
index aa6253a..7b31626 100644
--- a/apt-pkg/deb/debrecords.cc
+++ b/apt-pkg/deb/debrecords.cc
@@ -92,6 +92,14 @@ string debRecordParser::LongDesc()
    return Section.FindS("Description");
 }
 									/*}}}*/
+// RecordParser::Changelog - Return package changelog if any		/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+string debRecordParser::Changelog()
+{
+   return string("");
+}
+									/*}}}*/
 // RecordParser::SourcePkg - Return the source package name if any	/*{{{*/
 // ---------------------------------------------------------------------
 /* */
diff --git a/apt-pkg/deb/debrecords.h b/apt-pkg/deb/debrecords.h
index 8760c38..a71e9bd 100644
--- a/apt-pkg/deb/debrecords.h
+++ b/apt-pkg/deb/debrecords.h
@@ -44,6 +44,7 @@ class debRecordParser : public pkgRecords::Parser
    virtual string ShortDesc();
    virtual string LongDesc();
    virtual string Name();
+   virtual string Changelog();
 
    virtual void GetRec(const char *&Start,const char *&Stop);
    
diff --git a/apt-pkg/deb/debsrcrecords.h b/apt-pkg/deb/debsrcrecords.h
index ff14045..89cb18b 100644
--- a/apt-pkg/deb/debsrcrecords.h
+++ b/apt-pkg/deb/debsrcrecords.h
@@ -34,10 +34,14 @@ class debSrcRecordParser : public pkgSrcRecords::Parser
    virtual bool Step() {iOffset = Tags.Offset(); return Tags.Step(Sect);};
    virtual bool Jump(unsigned long Off) {iOffset = Off; return Tags.Jump(Sect,Off);};
 
+   // These refer to the archive file for the Version
+   virtual string FileName() const {return Sect.FindS("Filename");};
+
    virtual string Package() const {return Sect.FindS("Package");};
    virtual string Version() const {return Sect.FindS("Version");};
    virtual string Maintainer() const {return Sect.FindS("Maintainer");};
    virtual string Section() const {return Sect.FindS("Section");};
+   virtual string Changelog() const {return string("");};
    virtual const char **Binaries();
    virtual bool BuildDepends(vector<BuildDepRec> &BuildDeps, bool ArchOnly);
    virtual unsigned long Offset() {return iOffset;};
diff --git a/apt-pkg/deb/debsystem.cc b/apt-pkg/deb/debsystem.cc
index 5f5e7db..df1fd48 100644
--- a/apt-pkg/deb/debsystem.cc
+++ b/apt-pkg/deb/debsystem.cc
@@ -185,6 +185,8 @@ bool debSystem::ArchiveSupported(const char *Type)
 signed debSystem::Score(Configuration const &Cnf)
 {
    signed Score = 0;
+   if (Cnf.FindB("APT::Ignore-dpkg",true) == true)
+       return Score;
    if (FileExists(Cnf.FindFile("Dir::State::status","/var/lib/dpkg/status")) == true)
        Score += 10;
    if (FileExists(Cnf.FindFile("Dir::Bin::dpkg","/usr/bin/dpkg")) == true)
diff --git a/apt-pkg/depcache.cc b/apt-pkg/depcache.cc
index de8243f..cbcfd48 100644
--- a/apt-pkg/depcache.cc
+++ b/apt-pkg/depcache.cc
@@ -11,20 +11,27 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/depcache.h"
 #endif
+
+#include <config.h>
+
 #include <apt-pkg/depcache.h>
 #include <apt-pkg/version.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/sptr.h>
 #include <apt-pkg/algorithms.h>
 
+// for Debug::pkgMarkInstall
+#include <apt-pkg/configuration.h>
+
 // CNC:2002-07-05
 #include <apt-pkg/pkgsystem.h>
 
 // CNC:2003-03-17
-#include <config.h>
 #include <apt-pkg/luaiface.h>
     
 #include <apti18n.h>    
+
+#include <cstdio>
 									/*}}}*/
 
 // DepCache::pkgDepCache - Constructors					/*{{{*/
@@ -212,6 +219,18 @@ bool pkgDepCache::CheckDep(DepIterator Dep,int Type,PkgIterator &Res)
    PkgIterator Dep_ParentPkg = Dep.ParentPkg();
    pkgVersioningSystem &VS = this->VS();
 
+   static const char *lastV;
+   static const pkgCache::Dependency *lastD;
+   static bool lastRet;
+#define VS_CheckDep(V, D) \
+   ({ \
+      if (!(lastV == V && lastD == D)) { \
+	 lastV = V; lastD = D; \
+	 lastRet = VS.CheckDep(V, D); \
+      } \
+      lastRet; \
+   })
+
    /* Check simple depends. A depends -should- never self match but 
       we allow it anyhow because dpkg does. Technically it is a packaging
       bug. Conflicts may never self match */
@@ -228,20 +247,20 @@ bool pkgDepCache::CheckDep(DepIterator Dep,int Type,PkgIterator &Res)
 	       // CNC:2002-07-10 - RPM must check the dependency type to
 	       //		   properly define if it would be satisfied
 	       //		   or not.
-	       if (VS.CheckDep(Pkg.CurrentVer().VerStr(),Dep) == true)
+	       if (VS_CheckDep(Pkg.CurrentVer().VerStr(),Dep) == true)
 		  return true;
 	    break;
 
 	 case InstallVersion:
 	    if (PkgState[Pkg->ID].InstallVer != 0)
-	       if (VS.CheckDep(PkgState[Pkg->ID].InstVerIter(*this).VerStr(),
+	       if (VS_CheckDep(PkgState[Pkg->ID].InstVerIter(*this).VerStr(),
 				       Dep) == true)
 		  return true;
 	    break;
       
 	 case CandidateVersion:
 	    if (PkgState[Pkg->ID].CandidateVer != 0)
-	       if (VS.CheckDep(PkgState[Pkg->ID].CandidateVerIter(*this).VerStr(),
+	       if (VS_CheckDep(PkgState[Pkg->ID].CandidateVerIter(*this).VerStr(),
 				       Dep) == true)
 		  return true;
 	    break;
@@ -291,7 +310,7 @@ bool pkgDepCache::CheckDep(DepIterator Dep,int Type,PkgIterator &Res)
       }
       
       // Compare the versions.
-      if (VS.CheckDep(P.ProvideVersion(),Dep) == true) // CNC:2002-07-10
+      if (VS_CheckDep(P.ProvideVersion(),Dep) == true) // CNC:2002-07-10
       {
 	 Res = P_OwnerPkg;
 	 return true;
@@ -737,15 +756,10 @@ void pkgDepCache::MarkDelete(PkgIterator const &Pkg, bool rPurge)
 // DepCache::MarkInstall - Put the package in the install state		/*{{{*/
 // ---------------------------------------------------------------------
 /* */
-void pkgDepCache::MarkInstall(PkgIterator const &Pkg,bool AutoInst,
-			      unsigned long Depth)
+int pkgDepCache::MarkInstall0(PkgIterator const &Pkg)
 {
-   if (Depth > 100)
-      return;
-   
-   // Simplifies other routines.
    if (Pkg.end() == true)
-      return;
+      return -1;
    
    /* Check that it is not already marked for install and that it can be 
       installed */
@@ -756,16 +770,16 @@ void pkgDepCache::MarkInstall(PkgIterator const &Pkg,bool AutoInst,
    {
       if (P.CandidateVer == (Version *)Pkg.CurrentVer() && P.InstallVer == 0)
 	 MarkKeep(Pkg);
-      return;
+      return 0;
    }
 
    // See if there is even any possible instalation candidate
    if (P.CandidateVer == 0)
-      return;
+      return -1;
    
    // We dont even try to install virtual packages..
    if (Pkg->VersionList == 0)
-      return;
+      return -1;
    
    /* Target the candidate version and remove the autoflag. We reset the
       autoflag below if this was called recursively. Otherwise the user
@@ -782,11 +796,29 @@ void pkgDepCache::MarkInstall(PkgIterator const &Pkg,bool AutoInst,
    AddStates(Pkg);
    Update(Pkg);
    AddSizes(Pkg);
-   
-   if (AutoInst == false)
+
+   return 1;
+}
+
+void pkgDepCache::MarkInstallRec(PkgIterator const &Pkg,
+      bool Restricted, std::set<PkgIterator> &MarkAgain,
+      unsigned long Depth, const char *DebugStr)
+{
+   if (Depth > 100)
+      return;
+   if (MarkInstall0(Pkg) <= 0)
       return;
 
+#define DEBUG_MI(n, fmt, ...) if (DebugStr) \
+   fprintf(stderr, "%s:%*s " fmt "\n", DebugStr, (int)Depth*2+n, "", __VA_ARGS__)
+#define DEBUG_THIS(fmt, ...) DEBUG_MI(0, fmt, __VA_ARGS__)
+#define DEBUG_NEXT(fmt, ...) DEBUG_MI(1, fmt, __VA_ARGS__)
+
+   DEBUG_THIS("mark %s", Pkg.Name());
+
+   StateCache &P = PkgState[Pkg->ID];
    DepIterator Dep = P.InstVerIter(*this).DependsList();
+   bool AddMarkAgain = false;
    for (; Dep.end() != true;)
    {
       // Grok or groups
@@ -849,20 +881,32 @@ void pkgDepCache::MarkInstall(PkgIterator const &Pkg,bool AutoInst,
 	 // Select the highest priority providing package
 	 if (InstPkg.end() == true)
 	 {
+	    int CanSelect = 0;
 	    pkgPrioSortList(*Cache,Cur);
 	    for (; *Cur != 0; Cur++)
 	    {
 	       PkgIterator Pkg(*Cache,Cache->PkgP + (*Cur)->ParentPkg);
 	       if (PkgState[Pkg->ID].CandidateVer != *Cur)
 		  continue;
-	       InstPkg = Pkg;
-	       break;
+	       if (CanSelect++ == 0)
+		  InstPkg = Pkg;
+	       else
+		  break;
+	    }
+	    // In restricted mode, skip ambiguous dependencies.
+	    if (Restricted && CanSelect > 1) {
+	       DEBUG_NEXT("target %s AMB", P.Name());
+	       AddMarkAgain = true;
+	       continue;
 	    }
 	 }
-	 
+
+	 DEBUG_NEXT("target %s", P.Name());
+
 	 if (InstPkg.end() == false)
 	 {
-	    MarkInstall(InstPkg,true,Depth + 1);
+	    // Recursion is always restricted
+	    MarkInstallRec(InstPkg,/*Restricted*/true,MarkAgain,Depth+1,DebugStr);
 
 	    // Set the autoflag, after MarkInstall because MarkInstall unsets it
 	    if (P->CurrentVer == 0)
@@ -880,13 +924,67 @@ void pkgDepCache::MarkInstall(PkgIterator const &Pkg,bool AutoInst,
 	 {
 	    VerIterator Ver(*this,*I);
 	    PkgIterator Pkg = Ver.ParentPkg();
-      
+	    DEBUG_NEXT("delete %s", Pkg.Name());
 	    MarkDelete(Pkg);
 	    PkgState[Pkg->ID].Flags |= Flag::Auto;
 	 }
 	 continue;
       }      
    }
+
+   if (AddMarkAgain)
+      MarkAgain.insert(Pkg);
+}
+
+void pkgDepCache::MarkInstall1(PkgIterator const &Pkg,
+      std::set<PkgIterator> &MarkAgain)
+{
+   bool Debug = _config->FindB("Debug::pkgMarkInstall", false);
+   const char *DebugA = Debug ? "MI1a" : NULL;
+   const char *DebugB = Debug ? "MI1b" : NULL;
+   std::set<PkgIterator> MA;
+   std::set<PkgIterator>::iterator I;
+   MarkInstallRec(Pkg, true, MA, 0, DebugA);
+   while (1) {
+      std::set<PkgIterator> MAA;
+      for (I = MA.begin(); I != MA.end(); ++I)
+	 MarkInstallRec(*I, true, MAA, 0, DebugB);
+      if (MA == MAA)
+	 break;
+      MA = MAA;
+   }
+   for (I = MA.begin(); I != MA.end(); ++I)
+      MarkAgain.insert(*I);
+}
+
+void pkgDepCache::MarkInstall2(PkgIterator const &Pkg)
+{
+   bool Debug = _config->FindB("Debug::pkgMarkInstall", false);
+   const char *DebugA = Debug ? "MI2a" : NULL;
+   const char *DebugB = Debug ? "MI2b" : NULL;
+   const char *DebugC = Debug ? "MI2c" : NULL;
+   std::set<PkgIterator> MA;
+   std::set<PkgIterator>::iterator I;
+   MarkInstallRec(Pkg, true, MA, 0, DebugA);
+   while (1) {
+      std::set<PkgIterator> MAA;
+      for (I = MA.begin(); I != MA.end(); ++I)
+	 MarkInstallRec(*I, true, MAA, 0, DebugB);
+      for (I = MA.begin(); I != MA.end(); ++I)
+	 MarkInstallRec(*I, false, MAA, 0, DebugC);
+      if (MA == MAA)
+	 break;
+      MA = MAA;
+   }
+}
+
+void pkgDepCache::MarkInstall(PkgIterator const &Pkg,bool AutoInst,
+			      unsigned long Depth)
+{
+   if (AutoInst == false)
+      MarkInstall0(Pkg);
+   else
+      MarkInstall2(Pkg);
 }
 									/*}}}*/
 // DepCache::SetReInstall - Set the reinstallation flag			/*{{{*/
diff --git a/apt-pkg/depcache.h b/apt-pkg/depcache.h
index bb96afb..c7dd89e 100644
--- a/apt-pkg/depcache.h
+++ b/apt-pkg/depcache.h
@@ -42,6 +42,8 @@
 #pragma interface "apt-pkg/depcache.h"
 #endif
 
+#include <set>
+
 #include <apt-pkg/pkgcache.h>
 #include <apt-pkg/progress.h>
 
@@ -195,8 +197,21 @@ class pkgDepCache : protected pkgCache::Namespace
    // Manipulators
    void MarkKeep(PkgIterator const &Pkg,bool Soft = false);
    void MarkDelete(PkgIterator const &Pkg,bool Purge = false);
+
+   // shallow mark; ret: -1 err, 0 already marked, 1 just marked
+   int MarkInstall0(PkgIterator const &Pkg);
+   // non-ambiguous recursive mark; MarkAgain should be marked again
+   void MarkInstall1(PkgIterator const &Pkg, std::set<PkgIterator> &MarkAgain);
+   // full wavefront recursive mark
+   void MarkInstall2(PkgIterator const &Pkg);
+   // compat
    void MarkInstall(PkgIterator const &Pkg,bool AutoInst = true,
 		    unsigned long Depth = 0);
+   // implementation
+   void MarkInstallRec(PkgIterator const &Pkg,
+      bool Restricted, std::set<PkgIterator> &MarkAgain,
+      unsigned long Depth, const char *DebugStr);
+
    void SetReInstall(PkgIterator const &Pkg,bool To);
    void SetCandidateVersion(VerIterator TargetVer);
    
diff --git a/apt-pkg/indexfile.cc b/apt-pkg/indexfile.cc
index 378f1e0..f4553aa 100644
--- a/apt-pkg/indexfile.cc
+++ b/apt-pkg/indexfile.cc
@@ -12,8 +12,11 @@
 #pragma implementation "apt-pkg/indexfile.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/indexfile.h>
 #include <apt-pkg/error.h>
+#include <cstring>
 									/*}}}*/
 
 // Global list of Item supported
diff --git a/apt-pkg/init.cc b/apt-pkg/init.cc
index 815e828..c97879b 100644
--- a/apt-pkg/init.cc
+++ b/apt-pkg/init.cc
@@ -8,17 +8,20 @@
    ##################################################################### */
 									/*}}}*/
 // Include files							/*{{{*/
+#include <config.h>
 #include <apt-pkg/init.h>
 #include <apt-pkg/fileutl.h>
 #include <apt-pkg/error.h>
 
 #include <apti18n.h>
-#include <config.h>
 #include <sys/stat.h>
+#include <sys/utsname.h>
 
 // CNC:2003-03-17
 #include <apt-pkg/luaiface.h>
 
+#include <cstring>
+#include <cstdlib>
 									/*}}}*/
 
 #define Stringfy_(x) # x
@@ -37,47 +40,55 @@ const char *pkgOS = COMMON_OS;
    is prepended, this allows a fair degree of flexability. */
 bool pkgInitConfig(Configuration &Cnf)
 {
+   const char *cpu = NULL;
+   struct utsname name;
+   if (uname(&name) == 0)
+      cpu = strdup(name.machine);
+   if (cpu == NULL)
+      cpu = COMMON_CPU;
+
    // General APT things
    if (strcmp(COMMON_OS,"linux") == 0 ||
        strcmp(COMMON_OS,"unknown") == 0)
-      Cnf.Set("APT::Architecture",COMMON_CPU);
+      Cnf.CndSet("APT::Architecture",cpu);
    else
-      Cnf.Set("APT::Architecture",COMMON_OS "-" COMMON_CPU);
+      Cnf.CndSet("APT::Architecture",COMMON_OS "-" COMMON_CPU);
    // CNC:2002-09-10
-   //Cnf.Set("APT::Build-Essential::", "build-essential");
-   Cnf.Set("Dir","/");
+   //Cnf.CndSet("APT::Build-Essential::", "build-essential");
+   Cnf.CndSet("Dir","/");
    
    // State   
-   Cnf.Set("Dir::State","var/lib/apt/");
+   Cnf.CndSet("Dir::State","var/lib/apt/");
    
    /* Just in case something goes horribly wrong, we can fall back to the
       old /var/state paths.. */
    struct stat St;   
    if (stat("/var/lib/apt/.",&St) != 0 &&
        stat("/var/state/apt/.",&St) == 0)
-      Cnf.Set("Dir::State","var/state/apt/");
+      Cnf.CndSet("Dir::State","var/state/apt/");
        
-   Cnf.Set("Dir::State::lists","lists/");
-   Cnf.Set("Dir::State::cdroms","cdroms.list");
+   Cnf.CndSet("Dir::State::lists","lists/");
+   Cnf.CndSet("Dir::State::cdroms","cdroms.list");
    
    // Cache
-   Cnf.Set("Dir::Cache","var/cache/apt/");
-   Cnf.Set("Dir::Cache::archives","archives/");
-   Cnf.Set("Dir::Cache::srcpkgcache","srcpkgcache.bin");
-   Cnf.Set("Dir::Cache::pkgcache","pkgcache.bin");
+   Cnf.CndSet("Dir::Cache","var/cache/apt/");
+   Cnf.CndSet("Dir::Cache::archives","archives/");
+   Cnf.CndSet("Dir::Cache::srcpkgcache","srcpkgcache.bin");
+   Cnf.CndSet("Dir::Cache::pkgcache","pkgcache.bin");
    
    // Configuration
-   Cnf.Set("Dir::Etc","etc/apt/");
-   Cnf.Set("Dir::Etc::sourcelist","sources.list");
+   Cnf.CndSet("Dir::Etc","etc/apt/");
+   Cnf.CndSet("Dir::Etc::sourcelist","sources.list");
    // CNC:2003-03-03
-   Cnf.Set("Dir::Etc::sourceparts","sources.list.d");
-   Cnf.Set("Dir::Etc::vendorlist","vendors.list");
-   Cnf.Set("Dir::Etc::vendorparts","vendors.list.d");
-   Cnf.Set("Dir::Etc::main","apt.conf");
-   Cnf.Set("Dir::Etc::parts","apt.conf.d");
-   Cnf.Set("Dir::Etc::preferences","preferences");
-   Cnf.Set("Dir::Bin::methods",LIBDIR "/apt/methods");
-   Cnf.Set("Acquire::ComprExtension", ".bz2");
+   Cnf.CndSet("Dir::Etc::sourceparts","sources.list.d");
+   Cnf.CndSet("Dir::Etc::vendorlist","vendors.list");
+   Cnf.CndSet("Dir::Etc::vendorparts","vendors.list.d");
+   Cnf.CndSet("Dir::Etc::main","apt.conf");
+   Cnf.CndSet("Dir::Etc::parts","apt.conf.d");
+   Cnf.CndSet("Dir::Etc::preferences","preferences");
+   Cnf.CndSet("Dir::Etc::preferencesparts","preferences.d");
+   Cnf.CndSet("Dir::Bin::methods",LIBDIR "/apt/methods");
+   Cnf.CndSet("Acquire::ComprExtension", ".bz2");
 	      
    bool Res = true;
    
diff --git a/apt-pkg/luaiface.cc b/apt-pkg/luaiface.cc
index 28d3c17..9dc7f1b 100644
--- a/apt-pkg/luaiface.cc
+++ b/apt-pkg/luaiface.cc
@@ -17,12 +17,12 @@
 #ifdef WITH_LUA
 
 extern "C" {
-#include "lua.h"
-#include "lualib.h"
-#include "lauxlib.h"
-#include "lposix.h"
-#include "lrexlib.h"
-#include "linit.h"
+#include <lua.h>
+#include <lualib.h>
+#include <lauxlib.h>
+#if LUA_VERSION_NUM < 501
+#error lua 5.1 required
+#endif
 }
 
 #include <apt-pkg/depcache.h>
@@ -52,12 +52,9 @@ extern "C" {
    } while (0)
 
 #define checkudata(ctype, target, n) \
-   do { \
-      ctype *_tmp = (ctype *) luaL_checkudata(L, n, #ctype); \
-      if (_tmp != NULL) \
-	 target = *_tmp; \
-      else \
-	 target = NULL; \
+   do { ctype *_tmp; target = NULL; \
+      if ( !lua_isnil(L, n) && (_tmp = (ctype *) luaL_checkudata(L, n, #ctype)) ) \
+	    target = *_tmp; \
    } while (0)
 
 Lua *_GetLuaObj()
@@ -78,26 +75,13 @@ Lua::Lua()
 {
    _config->CndSet("Dir::Bin::scripts", "/usr/share/apt/scripts");
 
-   const luaL_reg lualibs[] = {
-      {"base", luaopen_base},
-      {"table", luaopen_table},
-      {"io", luaopen_io},
-      {"string", luaopen_string},
-      {"math", luaopen_math},
-      {"debug", luaopen_debug},
-      {"loadlib", luaopen_loadlib},
-      {"posix", luaopen_posix},
-      {"rex", luaopen_rex},
-      {"init", luaopen_init},
-      {"apt", luaopen_apt},
-      {NULL, NULL}
-   };
    L = lua_open();
-   const luaL_reg *lib = lualibs;
-   for (; lib->name; lib++) {
-      lib->func(L);  /* open library */
-      lua_settop(L, 0);  /* discard any results */
-   }
+   luaL_openlibs(L);
+
+   lua_pushcfunction(L, luaopen_apt);
+   lua_pushstring(L, "apt");
+   lua_call(L, 1, 0);
+
    luaL_newmetatable(L, "pkgCache::Package*");
    lua_pushstring(L, "__eq");
    lua_pushcfunction(L, AptLua_pkgcomp);
@@ -198,7 +182,7 @@ bool Lua::RunScripts(const char *ConfListKey, bool CacheChunks)
    lua_pushnil(L);
    lua_rawset(L, LUA_GLOBALSINDEX);
 
-   lua_pop(L, 1);
+   lua_settop(L, 0);
 
    return true;
 }
@@ -1398,6 +1382,18 @@ static int AptLua_gettext(lua_State *L)
    return 0;
 }
 
+static int AptLua_savestate(lua_State *L)
+{
+   _lua->SaveState();
+   return 0;
+}
+
+static int AptLua_restorestate(lua_State *L)
+{
+   _lua->RestoreState();
+   return 0;
+}
+
 static const luaL_reg aptlib[] = {
    {"confget",		AptLua_confget},
    {"confgetlist",	AptLua_confgetlist},
@@ -1446,6 +1442,8 @@ static const luaL_reg aptlib[] = {
    {"apterror",		AptLua_apterror},
    {"aptwarning",	AptLua_aptwarning},
    {"_",		AptLua_gettext},
+   {"savestate",	AptLua_savestate},
+   {"restorestate",	AptLua_restorestate},
    {NULL, NULL}
 };
 
diff --git a/apt-pkg/luaiface.h b/apt-pkg/luaiface.h
index ef783b3..7636d23 100644
--- a/apt-pkg/luaiface.h
+++ b/apt-pkg/luaiface.h
@@ -12,6 +12,7 @@
 #include <vector>
 
 #include <apt-pkg/pkgcache.h>
+#include <apt-pkg/depcache.h>
 
 using namespace std;
 
@@ -38,8 +39,9 @@ class Lua {
 
    vector<string> Globals;
 
-   pkgDepCache *DepCache;
    pkgCache *Cache;
+   pkgDepCache *DepCache;
+   pkgDepCache::State DepCacheState;
 
    LuaCacheControl *CacheControl;
 
@@ -54,8 +56,9 @@ class Lua {
    void RunInteractive(const string &PlaceHint)
 	 { RunInteractive(PlaceHint.c_str()); };
 
+   //or all of this RunScript should be void?
    bool RunScript(const string &Script, const string &ChunkCacheKey="")
-	 { RunScript(Script.c_str(), (ChunkCacheKey.length() == 0) ?
+	 { return RunScript(Script.c_str(), ChunkCacheKey.empty() ?
 				      NULL : ChunkCacheKey.c_str()); };
    bool RunScript(const char *Script, const char *ChunkCacheKey=NULL);
    bool RunScripts(const char *ConfListKey, bool CacheChunks=false);
@@ -100,6 +103,14 @@ class Lua {
    void ResetCaches()
       { DepCache = NULL; Cache = NULL; Fix = NULL; DontFix = false; };
 
+   void SaveState() {
+      DepCacheState.Save(DepCache);
+   };
+
+   void RestoreState() {
+      DepCacheState.Restore();
+   };
+
    // For API functions
    pkgDepCache *GetDepCache(lua_State *L=NULL);
    pkgCache *GetCache(lua_State *L=NULL);
diff --git a/apt-pkg/orderlist.cc b/apt-pkg/orderlist.cc
index 28d508b..ae93c9b 100644
--- a/apt-pkg/orderlist.cc
+++ b/apt-pkg/orderlist.cc
@@ -66,6 +66,8 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/orderlist.h"
 #endif 
+#include <config.h>
+
 #include <apt-pkg/orderlist.h>
 #include <apt-pkg/depcache.h>
 #include <apt-pkg/error.h>
@@ -299,7 +301,7 @@ int pkgOrderList::Score(PkgIterator Pkg)
    if (Cache[Pkg].InstVerIter(Cache).end() == true)
       return -1;
    
-   int Score = 0;
+   int Score = 1;
    if ((Pkg->Flags & pkgCache::Flag::Essential) == pkgCache::Flag::Essential)
       Score += 100;
 
@@ -310,7 +312,7 @@ int pkgOrderList::Score(PkgIterator Pkg)
 	D.end() == false; D++)
       if (D->Type == pkgCache::Dep::PreDepends)
       {
-	 Score += 50;
+	 Score -= 1;
 	 break;
       }
       
diff --git a/apt-pkg/packagemanager.cc b/apt-pkg/packagemanager.cc
index 6a0475b..8784399 100644
--- a/apt-pkg/packagemanager.cc
+++ b/apt-pkg/packagemanager.cc
@@ -17,6 +17,8 @@
 #pragma implementation "apt-pkg/packagemanager.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/packagemanager.h>
 #include <apt-pkg/orderlist.h>
 #include <apt-pkg/depcache.h>
@@ -216,7 +218,7 @@ bool pkgPackageManager::CheckRConflicts(PkgIterator Pkg,DepIterator D,
       if (D.ParentPkg() == Pkg || D.ParentVer() != D.ParentPkg().CurrentVer())
 	 continue;
       
-      if (Cache.VS().CheckDep(Ver,D) == false) // CNC:2002-07-10
+      if (D.TargetVer() == 0 || Cache.VS().CheckDep(Ver,D) == false) // CNC:2002-07-10
 	 continue;
 
       if (EarlyRemove(D.ParentPkg()) == false)
diff --git a/apt-pkg/pkgcache.cc b/apt-pkg/pkgcache.cc
index 317e064..7e87514 100644
--- a/apt-pkg/pkgcache.cc
+++ b/apt-pkg/pkgcache.cc
@@ -25,6 +25,9 @@
 #pragma implementation "apt-pkg/cacheiterators.h"
 #endif 
 
+#include <config.h>
+
+#define PKGCACHE_FINDPKG_ABI
 #include <apt-pkg/pkgcache.h>
 #include <apt-pkg/version.h>
 #include <apt-pkg/error.h>
@@ -37,6 +40,8 @@
 #include <sys/stat.h>
 #include <unistd.h>
 
+#include <assert.h>
+
 #include <ctype.h>
 #include <system.h>
 									/*}}}*/
@@ -183,22 +188,16 @@ unsigned long pkgCache::sHash(const char *Str) const
 // Cache::FindPkg - Locate a package by name				/*{{{*/
 // ---------------------------------------------------------------------
 /* Returns 0 on error, pointer to the package otherwise */
+pkgCache::PkgIterator pkgCache::FindPkg(const string &Name)
+{
+   return PkgIterator(*this,FindPackage(Name.c_str()));
+}
+#ifdef PKGCACHE_FINDPKG_ABI
 pkgCache::PkgIterator pkgCache::FindPkg(string Name)
 {
-   // Look at the hash bucket
-   Package *Pkg = PkgP + HeaderP->HashTable[Hash(Name)];
-   const char *name = Name.c_str(); // CNC:2003-02-17
-   for (; Pkg != PkgP; Pkg = PkgP + Pkg->NextPackage)
-   {
-      // CNC:2003-02-17 - We use case sensitive package names. Also,
-      //                  store Pkg->Name in a temporary variable.
-      map_ptrloc PkgName = Pkg->Name;
-      if (PkgName != 0 && StrP[PkgName] == name[0] &&
-	  strcmp(name,StrP + PkgName) == 0)
-	 return PkgIterator(*this,Pkg);
-   }
-   return PkgIterator(*this,0);
+   return PkgIterator(*this,FindPackage(Name.c_str()));
 }
+#endif
 									/*}}}*/
 
 // CNC:2003-02-17 - A slightly changed FindPkg(), hacked for performance.
@@ -211,12 +210,13 @@ pkgCache::Package *pkgCache::FindPackage(const char *Name)
    Package *Pkg = PkgP + HeaderP->HashTable[Hash(Name)];
    for (; Pkg != PkgP; Pkg = PkgP + Pkg->NextPackage)
    {
-      // CNC:2003-02-17 - We use case sensitive package names. Also,
-      //                  store Pkg->Name in a temporary variable.
+      // CNC:2003-02-17 - We use case sensitive package names.
       map_ptrloc PkgName = Pkg->Name;
-      if (PkgName != 0 && StrP[PkgName] == Name[0] &&
-	  strcmp(Name,StrP + PkgName) == 0)
-	 return Pkg;
+      if (PkgName != 0) {
+	 const char *S = StrP + PkgName;
+	 if (*S == *Name && strcmp(S, Name) == 0)
+	    return Pkg;
+      }
    }
    return NULL;
 }
@@ -393,11 +393,9 @@ bool pkgCache::DepIterator::SmartTargetPkg(PkgIterator &Result)
    must be delete [] 'd */
 pkgCache::Version **pkgCache::DepIterator::AllTargets()
 {
-   Version **Res = 0;
-   unsigned long Size =0;
-   while (1)
+   Version *Res[1024];
+   unsigned int Size = 0;
    {
-      Version **End = Res;
       PkgIterator DPkg = TargetPkg();
 
       // Walk along the actual package providing versions
@@ -410,10 +408,23 @@ pkgCache::Version **pkgCache::DepIterator::AllTargets()
 	      Dep->Type == pkgCache::Dep::Obsoletes) &&
 	     ParentPkg() == I.ParentPkg())
 	    continue;
-	 
-	 Size++;
-	 if (Res != 0)
-	    *End++ = I;
+
+	 Version *v = I;
+	 if (Res != 0 && Size > 0) {
+	    bool seen = false;
+	    for (unsigned int j = 0; j < Size; ++j) {
+	       Version *vj = Res[j];
+	       if (v == vj) {
+		  seen = true;
+		  break;
+	       }
+	    }
+	    if (seen)
+	       continue;
+	 }
+
+	 assert(Size < sizeof(Res)/sizeof(*Res));
+	 Res[Size++] = v;
       }
       
       // Follow all provides
@@ -426,26 +437,31 @@ pkgCache::Version **pkgCache::DepIterator::AllTargets()
 	      Dep->Type == pkgCache::Dep::Obsoletes) &&
 	     ParentPkg() == I.OwnerPkg())
 	    continue;
-	 
-	 Size++;
-	 if (Res != 0)
-	    *End++ = I.OwnerVer();
-      }
-      
-      // Do it again and write it into the array
-      if (Res == 0)
-      {
-	 Res = new Version *[Size+1];
-	 Size = 0;
+
+	 Version *v = I.OwnerVer();
+	 if (Res != 0 && Size > 0) {
+	    bool seen = false;
+	    for (unsigned int j = 0; j < Size; ++j) {
+	       Version *vj = Res[j];
+	       if (v == vj) {
+		  seen = true;
+		  break;
+	       }
+	    }
+	    if (seen)
+	       continue;
+	 }
+
+	 assert(Size < sizeof(Res)/sizeof(*Res));
+	 Res[Size++] = v;
       }
-      else
-      {
-	 *End = 0;
-	 break;
-      }      
    }
    
-   return Res;
+   Version **Ret = new Version *[Size+1];
+   if (Size)
+      memcpy(Ret, Res, Size*sizeof(*Res));
+   Ret[Size] = 0;
+   return Ret;
 }
 									/*}}}*/
 // DepIterator::GlobOr - Compute an OR group				/*{{{*/
diff --git a/apt-pkg/pkgcache.h b/apt-pkg/pkgcache.h
index 5069bc0..f9fb616 100644
--- a/apt-pkg/pkgcache.h
+++ b/apt-pkg/pkgcache.h
@@ -110,7 +110,7 @@ class pkgCache
 
    // CNC:2003-02-16 - Inlined here.
    inline unsigned long sHash(const char *S) const;
-   inline unsigned long sHash(string S) const {return sHash(S.c_str());};
+   inline unsigned long sHash(const string &S) const {return sHash(S.c_str());};
    
    public:
    
@@ -131,14 +131,17 @@ class pkgCache
    inline void *DataEnd() {return ((unsigned char *)Map.Data()) + Map.Size();};
       
    // String hashing function (512 range)
-   inline unsigned long Hash(string S) const {return sHash(S);};
-   inline unsigned long Hash(const char *S) const {return sHash(S);};
+   inline unsigned long Hash(const char *S) const;
+   inline unsigned long Hash(const string &S) const {return Hash(S.c_str());};
 
    // Usefull transformation things
    const char *Priority(unsigned char Priority);
    
    // Accessors
+   PkgIterator FindPkg(const string &Name);
+#ifdef PKGCACHE_FINDPKG_ABI
    PkgIterator FindPkg(string Name);
+#endif
    // CNC:2003-02-17 - A slightly changed FindPkg(), hacked for performance.
    Package *FindPackage(const char *Name);
    Header &Head() {return *HeaderP;};
@@ -203,7 +206,7 @@ struct pkgCache::Header
    DynamicMMap::Pool Pools[7];
    
    // Rapid package name lookup
-   map_ptrloc HashTable[8*1048];
+   map_ptrloc HashTable[64*1024];
 
    bool CheckSizes(Header &Against) const;
    Header();
@@ -227,7 +230,7 @@ struct pkgCache::Package
    unsigned char InstState;         // Flags
    unsigned char CurrentState;      // State
    
-   unsigned short ID;
+   unsigned int ID;
    unsigned long Flags;
 };
 
@@ -263,9 +266,10 @@ struct pkgCache::VerFile
 struct pkgCache::Version
 {
    map_ptrloc VerStr;            // Stringtable
+   map_ptrloc BTime;             // int
    map_ptrloc Section;           // StringTable (StringItem)
    map_ptrloc Arch;              // StringTable
-      
+
    // Lists
    map_ptrloc FileList;          // VerFile
    map_ptrloc NextVer;           // Version
@@ -275,8 +279,8 @@ struct pkgCache::Version
    
    map_ptrloc Size;              // These are the .deb size
    map_ptrloc InstalledSize;
-   unsigned short Hash;
-   unsigned short ID;
+   unsigned int Hash;
+   unsigned int ID;
    unsigned char Priority;
 };
 
@@ -312,15 +316,18 @@ struct pkgCache::StringItem
 #include <apt-pkg/cacheiterators.h>
 
 // CNC:2003-02-16 - Inlined here.
-#include <ctype.h>
+inline unsigned long pkgCache::sHash(const char *S) const
+{
+   unsigned long h = 5381;
+   unsigned char c;
+   for (c = *S; c != '\0'; c = *++S)
+      h = h * 33 + c;
+   return h;
+}
 #define hash_count(a) (sizeof(a)/sizeof(a[0]))
-inline unsigned long pkgCache::sHash(const char *Str) const
+inline unsigned long pkgCache::Hash(const char *S) const
 {
-   unsigned long Hash = 0;
-   for (const char *I = Str; *I != 0; I++)
-      //Hash = 5*Hash + tolower(*I);
-      Hash = 5*Hash + *I;
-   return Hash % hash_count(HeaderP->HashTable);
+   return sHash(S) % hash_count(HeaderP->HashTable);
 }
 #undef hash_count
 
diff --git a/apt-pkg/pkgcachegen.cc b/apt-pkg/pkgcachegen.cc
index 126f0b2..2313553 100644
--- a/apt-pkg/pkgcachegen.cc
+++ b/apt-pkg/pkgcachegen.cc
@@ -16,6 +16,8 @@
 
 #define APT_COMPATIBILITY 986
 
+#include <config.h>
+
 #include <apt-pkg/pkgcachegen.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/version.h>
@@ -144,6 +146,7 @@ bool pkgCacheGenerator::MergeList(ListParser &List,
 
       // CNC:2002-07-09
       string Arch = List.Architecture();
+      int BuildTime = List.BuildTime();
 
       pkgCache::VerIterator Ver = Pkg.VersionList();
       map_ptrloc *Last = &Pkg->VersionList;
@@ -158,10 +161,18 @@ bool pkgCacheGenerator::MergeList(ListParser &List,
 	 else
 	    Res = Cache.VS->CmpVersionArch(Version,Arch,
 					   Ver.VerStr(),Ver.Arch());
+
+	 if (Res == 0) {
+	    int BTime = Ver.BTime();
+	    if (BuildTime < BTime)
+	       Res = -1;
+	    else if (BuildTime > BTime)
+	       Res = 1;
+	 }
 	 if (Res >= 0)
 	    break;
       }
-      
+
       /* We already have a version for this item, record that we
          saw it */
       unsigned long Hash = List.VersionHash();
@@ -196,6 +207,13 @@ bool pkgCacheGenerator::MergeList(ListParser &List,
 	    // CNC:2002-07-09
 	    Res = Cache.VS->CmpVersionArch(Version,Arch,
 			    		   Ver.VerStr(),Ver.Arch());
+	    if (Res == 0) {
+		    int BTime = Ver.BTime();
+		    if (BuildTime < BTime)
+			    Res = -1;
+		    else if (BuildTime > BTime)
+			    Res = 1;
+	    }
 	    if (Res != 0)
 	       break;
 	 }
@@ -260,6 +278,7 @@ bool pkgCacheGenerator::MergeFileProvides(ListParser &List)
       string Version = List.Version();
       if (Version.empty() == true)
 	 continue;
+      int BuildTime = List.BuildTime();
       
       pkgCache::PkgIterator Pkg = Cache.FindPkg(PackageName);
       if (Pkg.end() == true)
@@ -289,7 +308,7 @@ bool pkgCacheGenerator::MergeFileProvides(ListParser &List)
       for (; Ver.end() == false; Ver++)
       {
 	 // CNC:2002-07-25
-	 if (Ver->Hash == Hash && strcmp(Version.c_str(), Ver.VerStr()) == 0)
+	 if (Ver->Hash == Hash && strcmp(Version.c_str(), Ver.VerStr()) == 0 && BuildTime == Ver.BTime())
 	 {
 	    if (List.CollectFileProvides(Cache,Ver) == false)
 	       return _error->Error(_("Error occured while processing %s (CollectFileProvides)"),PackageName.c_str());
@@ -481,9 +500,12 @@ bool pkgCacheGenerator::ListParser::NewProvides(pkgCache::VerIterator Ver,
 {
    pkgCache &Cache = Owner->Cache;
 
+// PM:2006-02-07 allow self-referencing provides for now at least...
+#if 0
    // We do not add self referencing provides
    if (Ver.ParentPkg().Name() == PackageName)
       return true;
+#endif
    
    // Get a structure
    unsigned long Provides = Owner->Map.Allocate(sizeof(pkgCache::Provides));
@@ -758,7 +780,7 @@ static bool CollectFileProvides(pkgCacheGenerator &Gen,
 bool pkgMakeStatusCache(pkgSourceList &List,OpProgress &Progress,
 			MMap **OutMap,bool AllowMem)
 {
-   unsigned long MapSize = _config->FindI("APT::Cache-Limit",12*1024*1024);
+   unsigned long MapSize = _config->FindI("APT::Cache-Limit",(64+4*sizeof(long))*1024*1024);
    
    vector<pkgIndexFile *> Files(List.begin(),List.end());
    unsigned long EndOfSource = Files.size();
@@ -805,10 +827,10 @@ bool pkgMakeStatusCache(pkgSourceList &List,OpProgress &Progress,
    {
       unlink(CacheFile.c_str());
       CacheF = new FileFd(CacheFile,FileFd::WriteEmpty);
-      fchmod(CacheF->Fd(),0644);
-      Map = new DynamicMMap(*CacheF,MMap::Public,MapSize);
       if (_error->PendingError() == true)
 	 return false;
+      fchmod(CacheF->Fd(),0644);
+      Map = new DynamicMMap(*CacheF,MMap::Public,MapSize);
    }
    else
    {
@@ -902,10 +924,10 @@ bool pkgMakeStatusCache(pkgSourceList &List,OpProgress &Progress,
       // even if using the sources cache (above).
       if (Writeable == true && SrcCacheFile.empty() == false)
       {
+	 unlink(SrcCacheFile.c_str());
 	 FileFd SCacheF(SrcCacheFile,FileFd::WriteEmpty);
 	 if (_error->PendingError() == true)
 	    return false;
-	 
 	 fchmod(SCacheF.Fd(),0644);
 	 
 	 // Write out the main data
@@ -971,7 +993,7 @@ bool pkgMakeStatusCache(pkgSourceList &List,OpProgress &Progress,
 /* */
 bool pkgMakeOnlyStatusCache(OpProgress &Progress,DynamicMMap **OutMap)
 {
-   unsigned long MapSize = _config->FindI("APT::Cache-Limit",8*1024*1024);
+   unsigned long MapSize = _config->FindI("APT::Cache-Limit",(64+4*sizeof(long))*1024*1024);
    vector<pkgIndexFile *> Files;
    unsigned long EndOfSource = Files.size();
    if (_system->AddStatusFiles(Files) == false)
diff --git a/apt-pkg/pkgcachegen.h b/apt-pkg/pkgcachegen.h
index 6a698be..c3ac3ea 100644
--- a/apt-pkg/pkgcachegen.h
+++ b/apt-pkg/pkgcachegen.h
@@ -59,7 +59,7 @@ class pkgCacheGenerator
    public:
 
    // CNC:2003-02-27 - We need this in rpmListParser.
-   bool NewPackage(pkgCache::PkgIterator &Pkg,string Pkg);
+   bool NewPackage(pkgCache::PkgIterator &PkgI,string Pkg);
 
    unsigned long WriteUniqString(const char *S,unsigned int Size);
    inline unsigned long WriteUniqString(string S) {return WriteUniqString(S.c_str(),S.length());};
@@ -141,6 +141,7 @@ class pkgCacheGenerator::ListParser
 
    ListParser() : FoundFileDeps(false) {};
    virtual ~ListParser() {};
+   virtual int BuildTime() = 0;
 };
 
 bool pkgMakeStatusCache(pkgSourceList &List,OpProgress &Progress,
diff --git a/apt-pkg/pkgrecords.cc b/apt-pkg/pkgrecords.cc
index b39031b..8b81d85 100644
--- a/apt-pkg/pkgrecords.cc
+++ b/apt-pkg/pkgrecords.cc
@@ -12,12 +12,15 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/pkgrecords.h"
 #endif
+#include <config.h>
+
 #include <apt-pkg/pkgrecords.h>
 #include <apt-pkg/indexfile.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/configuration.h>
     
 #include <apti18n.h>   
+#include <cstring>
 									/*}}}*/
 
 // Records::pkgRecords - Constructor					/*{{{*/
@@ -56,7 +59,8 @@ pkgRecords::~pkgRecords()
 {
    // CNC:2002-11-28
    // See comments above.
-   for (unsigned I = 0; I != PackageFileCount; I++)
+   // PackageFileCount is int according to apt-pkg/pkgrecords.h
+   for (int I = 0; I != PackageFileCount; I++)
       delete Files[I];
    delete [] Files;
 }
diff --git a/apt-pkg/pkgrecords.h b/apt-pkg/pkgrecords.h
index 1bf1f9e..9f831a3 100644
--- a/apt-pkg/pkgrecords.h
+++ b/apt-pkg/pkgrecords.h
@@ -67,6 +67,7 @@ class pkgRecords::Parser
    virtual string ShortDesc() {return string();};
    virtual string LongDesc() {return string();};
    virtual string Name() {return string();};
+   virtual string Changelog() {return string();};
    
    // The record in binary form
    virtual void GetRec(const char *&Start,const char *&Stop) {Start = Stop = 0;};
diff --git a/apt-pkg/pkgsystem.cc b/apt-pkg/pkgsystem.cc
index e8ada85..987b02b 100644
--- a/apt-pkg/pkgsystem.cc
+++ b/apt-pkg/pkgsystem.cc
@@ -14,8 +14,11 @@
 #pragma implementation "apt-pkg/pkgsystem.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/pkgsystem.h>
 #include <apt-pkg/policy.h>
+#include <cstring>
 									/*}}}*/
 
 pkgSystem *_system = 0;
diff --git a/apt-pkg/pkgsystem.h b/apt-pkg/pkgsystem.h
index 6ea113d..50bbbf4 100644
--- a/apt-pkg/pkgsystem.h
+++ b/apt-pkg/pkgsystem.h
@@ -90,7 +90,7 @@ class pkgSystem
    // Return a list of system index files..
    virtual bool AddStatusFiles(std::vector<pkgIndexFile *> &List) = 0;   
    // CNC:2003-11-21
-   virtual bool AddSourceFiles(std::vector<pkgIndexFile *> &List) {};
+   virtual void AddSourceFiles(std::vector<pkgIndexFile *> &List) {};
    virtual bool FindIndex(pkgCache::PkgFileIterator File,
 			  pkgIndexFile *&Found) const = 0;
    
diff --git a/apt-pkg/policy.cc b/apt-pkg/policy.cc
index c615dc2..8223628 100644
--- a/apt-pkg/policy.cc
+++ b/apt-pkg/policy.cc
@@ -26,6 +26,8 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/policy.h"
 #endif
+#include <config.h>
+
 #include <apt-pkg/policy.h>
 #include <apt-pkg/configuration.h>
 #include <apt-pkg/tagfile.h>
@@ -35,6 +37,9 @@
     
 #include <apti18n.h>
 
+#include <dirent.h>
+#include <sys/stat.h>
+#include <algorithm>
 #include <iostream>
 									/*}}}*/
 
@@ -297,6 +302,54 @@ signed short pkgPolicy::GetPkgPriority(const pkgCache::PkgIterator &Pkg)
    }
    return Max;
 }
+
+bool ReadPinDir(pkgPolicy &Plcy,string Dir)
+{
+   if (Dir.empty() == true)
+   {
+      Dir = _config->FindDir("Dir::Etc::PreferencesParts");
+      if (FileExists(Dir) == false)
+	 return true;
+   }
+
+   DIR *D = opendir(Dir.c_str());
+   if (D == 0)
+      return _error->Errno("opendir",_("Unable to read %s"),Dir.c_str());
+
+   vector<string> List;
+   
+   for (struct dirent *Ent = readdir(D); Ent != 0; Ent = readdir(D))
+   {
+      if (Ent->d_name[0] == '.')
+	 continue;
+      
+      // Skip bad file names ala run-parts
+      const char *C = Ent->d_name;
+      for (; *C != 0; C++)
+	 if (isalpha(*C) == 0 && isdigit(*C) == 0 && *C != '_' && *C != '-')
+	    break;
+      if (*C != 0)
+	 continue;
+      
+      // Make sure it is a file and not something else
+      string File = flCombine(Dir,Ent->d_name);
+      struct stat St;
+      if (stat(File.c_str(),&St) != 0 || S_ISREG(St.st_mode) == 0)
+	 continue;
+      
+      List.push_back(File);      
+   }   
+   closedir(D);
+   
+   sort(List.begin(),List.end());
+
+   // Read the files
+   for (vector<string>::const_iterator I = List.begin(); I != List.end(); I++)
+      if (ReadPinFile(Plcy, *I) == false)
+	 return false;
+   return true;
+}
+   
 									/*}}}*/
 
 // ReadPinFile - Load the pin file into a Policy			/*{{{*/
@@ -323,7 +376,7 @@ bool ReadPinFile(pkgPolicy &Plcy,string File)
    {
       string Name = Tags.FindS("Package");
       if (Name.empty() == true)
-	 return _error->Error(_("Invalid record in the preferences file, no Package header"));
+	 return _error->Error(_("Invalid record in the preferences file %s, no Package header"), File.c_str());
       if (Name == "*")
 	 Name = string();
       
diff --git a/apt-pkg/policy.h b/apt-pkg/policy.h
index 563c8d7..f4ec09c 100644
--- a/apt-pkg/policy.h
+++ b/apt-pkg/policy.h
@@ -94,5 +94,6 @@ class pkgPolicy : public pkgDepCache::Policy
 };
 
 bool ReadPinFile(pkgPolicy &Plcy,string File = "");
+bool ReadPinDir(pkgPolicy &Plcy,string Dir = "");
 
 #endif
diff --git a/apt-pkg/repository.cc b/apt-pkg/repository.cc
index 7cbc92f..5507d24 100644
--- a/apt-pkg/repository.cc
+++ b/apt-pkg/repository.cc
@@ -14,6 +14,8 @@
 #pragma implementation "apt-pkg/repository.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/sourcelist.h>
 #include <apt-pkg/repository.h>
 #include <apt-pkg/error.h>
diff --git a/apt-pkg/repository.h b/apt-pkg/repository.h
index 189001b..9a15dcb 100644
--- a/apt-pkg/repository.h
+++ b/apt-pkg/repository.h
@@ -33,7 +33,7 @@ class pkgRepository
 
    string URI;
    string Dist;
-   string FingerPrint;
+   vector<string> FingerPrint;
    string RootURI;
 
    bool Acquire;
diff --git a/apt-pkg/rpm/rpmhandler.cc b/apt-pkg/rpm/rpmhandler.cc
index 0413a49..44a35a6 100644
--- a/apt-pkg/rpm/rpmhandler.cc
+++ b/apt-pkg/rpm/rpmhandler.cc
@@ -87,7 +87,7 @@ bool RPMFileHandler::Jump(unsigned Offset)
 {
    if (FD == NULL)
       return false;
-   if (lseek(Fileno(FD),Offset,SEEK_SET) != Offset)
+   if (lseek(Fileno(FD),Offset,SEEK_SET) != (off_t)Offset)
       return false;
    return Skip();
 }
@@ -347,7 +347,7 @@ string RPMDirHandler::MD5Sum()
 
 
 RPMDBHandler::RPMDBHandler(bool WriteLock)
-   : WriteLock(WriteLock), Handler(0)
+   : Handler(0), WriteLock(WriteLock)
 {
 #if RPM_VERSION >= 0x040000
    RpmIter = NULL;
diff --git a/apt-pkg/rpm/rpmhandler.h b/apt-pkg/rpm/rpmhandler.h
index 28eeb6b..06fd319 100644
--- a/apt-pkg/rpm/rpmhandler.h
+++ b/apt-pkg/rpm/rpmhandler.h
@@ -10,13 +10,15 @@
 #ifndef PKGLIB_RPMHANDLER_H
 #define PKGLIB_RPMHANDLER_H
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <apt-pkg/fileutl.h>
 
 #include <rpm/rpmlib.h>
 #include <rpm/rpmmacro.h>
 
-#include <config.h>
-
 class RPMHandler
 {
    protected:
diff --git a/apt-pkg/rpm/rpmlistparser.cc b/apt-pkg/rpm/rpmlistparser.cc
index e56e92a..287f838 100644
--- a/apt-pkg/rpm/rpmlistparser.cc
+++ b/apt-pkg/rpm/rpmlistparser.cc
@@ -226,6 +226,26 @@ string rpmListParser::Version()
    }
    return str;
 }
+
+                                                                        /*}}}*/
+// ListParser::BuildTime - Return the buildtime				/*{{{*/
+// ---------------------------------------------------------------------
+/* This is to return the int describing the buildtime. */
+int rpmListParser::BuildTime()
+{
+#ifdef WITH_VERSION_CACHING
+   if (VI != NULL)
+      return VI->BTime();
+#endif
+
+   int *buildtime;
+   int type, count;
+
+   if (headerGetEntry(header, RPMTAG_BUILDTIME, &type, (void **)&buildtime, &count) == 1
+       && count > 0)
+	   return buildtime[0];
+   return 0;
+}
                                                                         /*}}}*/
 // ListParser::NewVersion - Fill in the version structure		/*{{{*/
 // ---------------------------------------------------------------------
@@ -243,7 +263,11 @@ bool rpmListParser::NewVersion(pkgCache::VerIterator Ver)
    // Parse the section
    Ver->Section = UniqFindTagWrite(RPMTAG_GROUP);
    Ver->Arch = UniqFindTagWrite(RPMTAG_ARCH);
-   
+
+   headerGetEntry(header, RPMTAG_BUILDTIME, &type, (void**)&num, &count);
+   if (type == RPM_INT32_TYPE && num)
+       Ver->BTime = *num;
+
    // Archive Size
    Ver->Size = Handler->FileSize();
    
diff --git a/apt-pkg/rpm/rpmlistparser.h b/apt-pkg/rpm/rpmlistparser.h
index 319dc53..16de5f6 100644
--- a/apt-pkg/rpm/rpmlistparser.h
+++ b/apt-pkg/rpm/rpmlistparser.h
@@ -62,6 +62,7 @@ class rpmListParser : public pkgCacheGenerator::ListParser
    // These all operate against the current header
    virtual string Package();
    virtual string Version();
+   virtual int BuildTime();
    virtual string Architecture();
    virtual bool NewVersion(pkgCache::VerIterator Ver);
    virtual unsigned short VersionHash();
diff --git a/apt-pkg/rpm/rpmmisc.h b/apt-pkg/rpm/rpmmisc.h
index bc28c20..8aadc51 100644
--- a/apt-pkg/rpm/rpmmisc.h
+++ b/apt-pkg/rpm/rpmmisc.h
@@ -4,6 +4,7 @@
 #ifdef WITH_GNU_HASH_MAP
 
 #include <ext/hash_map>
+#include <cstring>
 
 using namespace __gnu_cxx;
 
diff --git a/apt-pkg/rpm/rpmpackagedata.cc b/apt-pkg/rpm/rpmpackagedata.cc
index 0ce30fd..b0943f0 100644
--- a/apt-pkg/rpm/rpmpackagedata.cc
+++ b/apt-pkg/rpm/rpmpackagedata.cc
@@ -39,7 +39,7 @@ RPMPackageData::RPMPackageData()
    }
 
    // Populate priorities
-   string FileName = _config->FindFile("Dir::Etc::rpmpriorities");
+   string FileName = _config->FindFile("Dir::Etc::pkgpriorities");
    FileFd F(FileName, FileFd::ReadOnly);
    if (_error->PendingError()) 
    {
@@ -296,7 +296,6 @@ int RPMPackageData::RpmArchScore(const char *Arch)
 
 bool RPMPackageData::IsCompatArch(string Arch)
 {
-   bool compat = false;
    for (vector<string>::iterator I = CompatArch[BaseArch].begin();
         I != CompatArch[BaseArch].end(); I++) {
       if (Arch == *I)
diff --git a/apt-pkg/rpm/rpmpackagedata.h b/apt-pkg/rpm/rpmpackagedata.h
index 0977910..0a7d044 100644
--- a/apt-pkg/rpm/rpmpackagedata.h
+++ b/apt-pkg/rpm/rpmpackagedata.h
@@ -8,6 +8,7 @@
 #include <map>
 #include <vector>
 #include <regex.h>
+#include <cstring>
 
 using namespace std;
 
@@ -75,7 +76,7 @@ class RPMPackageData
    {
       if (Priorities.find(Package) != Priorities.end())
 	 return Priorities[Package];
-      return pkgCache::State::Standard;
+      return pkgCache::State::Optional;
    };
    inline pkgCache::Flag::PkgFlags PkgFlags(const string &Package) 
    	{return Flags[Package];};
diff --git a/apt-pkg/rpm/rpmpm.cc b/apt-pkg/rpm/rpmpm.cc
index c5a13dc..e6518f5 100644
--- a/apt-pkg/rpm/rpmpm.cc
+++ b/apt-pkg/rpm/rpmpm.cc
@@ -33,6 +33,7 @@
 #include <errno.h>
 #include <stdio.h>
 #include <iostream>
+#include <cstring>
 
 #if RPM_VERSION >= 0x040100
 #include <rpm/rpmdb.h>
@@ -259,23 +260,38 @@ bool pkgRPMPM::Go()
    
    for (vector<Item>::iterator I = List.begin(); I != List.end(); I++)
    {
+      string Name = I->Pkg.Name();
+      string::size_type loc;
+      bool NeedLabel;
+
       switch (I->Op)
       {
       case Item::Purge:
       case Item::Remove:
-	 if (strchr(I->Pkg.Name(), '#') != NULL)
-	 {
-	    char *name = strdup(I->Pkg.Name());
-	    char *p = strchr(name, '#');
-	    *(p++) = '-';
-	    const char *epoch = strchr(p, ':');
-	    if (epoch != NULL)
-	       memmove(p, epoch+1, strlen(epoch+1)+1);
-	    unalloc.push_back(name);
-	    uninstall.push_back(name);
+	 // Unmunge our package names so rpm can find them...
+	 NeedLabel = false;
+	 if ((loc = Name.find('#')) != string::npos) {
+	    Name = Name.substr(0,loc);
+	    NeedLabel = true;
+	 }
+	 if ((loc = Name.rfind(".32bit")) != string::npos &&
+	       loc == Name.length() - strlen(".32bit"))
+	    Name = Name.substr(0,loc);
+	 if (NeedLabel) {
+	    const char *VerStr = I->Pkg.CurrentVer().VerStr();
+	    const char *Epoch = strchr(VerStr, ':');
+	    if (Epoch)
+	       VerStr = Epoch + 1;
+	    Name += "-";
+	    Name += VerStr;
 	 }
-	 else
-	    uninstall.push_back(I->Pkg.Name());
+#if RPM_VERSION >= 0x040202
+	 // This is needed for removal to work on multilib packages, but old
+	 // rpm versions don't support name.arch in RPMDBI_LABEL, oh well...
+	 Name = Name + "." + I->Pkg.CurrentVer().Arch();
+#endif
+	 uninstall.push_back(strdup(Name.c_str()));
+	 unalloc.push_back(strdup(Name.c_str()));
 	 pkgs_uninstall.push_back(I->Pkg);
 	 break;
 
@@ -283,12 +299,9 @@ bool pkgRPMPM::Go()
 	 break;
 
        case Item::Install:
-	 if (strchr(I->Pkg.Name(), '#') != NULL) {
-	    char *name = strdup(I->Pkg.Name());
-	    char *p = strchr(name, '#');
-	    *p = 0;
-	    PkgIterator Pkg = Cache.FindPkg(name);
-	    free(name);
+	 if ((loc = Name.find('#')) != string::npos) {
+	    Name = Name.substr(0,loc);
+	    PkgIterator Pkg = Cache.FindPkg(Name);
 	    PrvIterator Prv = Pkg.ProvidesList();
 	    bool Installed = false;
 	    for (; Prv.end() == false; Prv++) {
@@ -391,41 +404,53 @@ pkgRPMExtPM::~pkgRPMExtPM()
 
 bool pkgRPMExtPM::ExecRPM(Item::RPMOps op, vector<const char*> &files)
 {
-   const char *Args[10000];      
+   const char *Args[10000];
    const char *operation;
    unsigned int n = 0;
    bool Interactive = _config->FindB("RPM::Interactive",true);
-   
-   Args[n++] = _config->Find("Dir::Bin::rpm","rpm").c_str();
+   int quiet = _config->FindI("quiet",0);
+
+   string rpmbinary = _config->Find("Dir::Bin::rpm","rpm");
+   Args[n++] = rpmbinary.c_str();
 
-   bool nodeps;
+   bool nodeps = false;
 
    switch (op)
    {
       case Item::RPMInstall:
-	 if (Interactive)
-	    operation = "-ivh";
-	 else
-	    operation = "-iv";
+	 operation = "-i";
 	 nodeps = true;
 	 break;
 
       case Item::RPMUpgrade:
-	 if (Interactive)
-	    operation = "-Uvh";
-	 else
-	    operation = "-Uv";
+	 operation = "-U";
 	 break;
 
       case Item::RPMErase:
 	 operation = "-e";
 	 nodeps = true;
 	 break;
+	default:
+	 return false;
    }
    Args[n++] = operation;
 
-   if (Interactive == false && op != Item::RPMErase)
-      Args[n++] = "--percent";
+	if (quiet <= 2 && op != Item::RPMErase)
+	{
+		Args[n++] = "-v";
+		if (quiet <= 1)
+		{
+			if (Interactive)
+			{
+				Args[n++] = "-h";
+				if (quiet <= 0)
+					Args[n++] = "--fancypercent";
+			} else
+			{
+				Args[n++] = "--percent";
+			}
+		}
+	}
     
    string rootdir = _config->Find("RPM::RootDir", "");
    if (!rootdir.empty()) 
@@ -499,8 +524,16 @@ bool pkgRPMExtPM::ExecRPM(Item::RPMOps op, vector<const char*> &files)
       }	 
    }
 
-   if (_config->FindB("RPM::Order", false) == false)
+   if (_config->FindB("RPM::Order", true) == false)
       Args[n++] = "--noorder";
+      
+    string cmd;
+    for (unsigned i = 0; i < n; ++i)
+    {
+	if (!cmd.empty())
+	    cmd += ' ';
+	    cmd += Args[i];
+    }
     
    bool FilesInArgs = true;
    char *ArgsFileName = NULL;
@@ -546,7 +579,8 @@ bool pkgRPMExtPM::ExecRPM(Item::RPMOps op, vector<const char*> &files)
       return true;
    }
 
-   cout << _("Executing RPM (")<<operation<<")..." << endl;
+   if (quiet <= 2)
+   cout << _("Executing RPM (")<<cmd<<")..." << endl;
 
    cout << flush;
    clog << flush;
@@ -626,7 +660,7 @@ bool pkgRPMExtPM::ExecRPM(Item::RPMOps op, vector<const char*> &files)
       return _error->Error(_("Sub-process %s exited unexpectedly"),Args[0]);
    }
 
-   if (Interactive == true)
+   if (quiet <= 2)
       cout << _("Done.") << endl;
 
    return true;
@@ -662,8 +696,7 @@ pkgRPMLibPM::~pkgRPMLibPM()
 
 bool pkgRPMLibPM::AddToTransaction(Item::RPMOps op, vector<const char*> &files)
 {
-   int debug = _config->FindB("Debug::pkgRPMPM", false);
-   int n = 0, rc, xx;
+   int rc;
    FD_t fd;
    rpmHeader hdr;
 
@@ -744,8 +777,8 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
    int rc = 0;
    bool Success = false;
    bool Interactive = _config->FindB("RPM::Interactive",true);
-   int debug = _config->FindB("Debug::pkgRPMPM", false);
    string Dir = _config->Find("RPM::RootDir");
+   int quiet = _config->FindI("quiet",0);
    rpmReadConfigFiles(NULL, NULL);
 
    int probFilter = 0;
@@ -775,7 +808,7 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
    const char *RootDir = NULL;
    if (!Dir.empty())
       RootDir = Dir.c_str();
-   if (rpmdbOpen(RootDir, &DB, O_RDWR, 0644) != 0)
+   if (rpmdbOpen(RootDir, &DB, O_RDWR|O_CREAT, 0644) != 0)
    {
       _error->Error(_("Could not open RPM database"));
       goto exit;
@@ -783,11 +816,6 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
    TS = rpmtransCreateSet(DB, Dir.c_str());
 #endif
 
-#if RPM_VERSION >= 0x040000
-   if (rpmExpandNumeric("%{?_repackage_all_erasures}"))
-      tsFlags |= RPMTRANS_FLAG_REPACKAGE;
-#endif
-		     
 #if RPM_VERSION >= 0x040300
    /* Initialize security context patterns for SELinux */
    if (!(tsFlags & RPMTRANS_FLAG_NOCONTEXTS)) {
@@ -813,10 +841,21 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
       probFilter |= RPMPROB_FILTER_REPLACENEWFILES;
    }
 
-   if (Interactive == true)
-       notifyFlags |= INSTALL_LABEL | INSTALL_HASH;
-   else
-       notifyFlags |= INSTALL_LABEL | INSTALL_PERCENT;
+    if (quiet <= 2)
+	notifyFlags |= INSTALL_LABEL;
+
+    if (quiet <= 1)
+    {
+	if (Interactive == true)
+	{
+	    notifyFlags |= INSTALL_HASH;
+	    extern int fancyPercents;
+	    fancyPercents = (quiet <= 0) ? 1 : 0;
+	} else
+	{
+		notifyFlags |= INSTALL_PERCENT;
+	}
+    }
 
    if (uninstall.empty() == false)
        AddToTransaction(Item::RPMErase, uninstall);
@@ -840,14 +879,14 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
       }
    }
 #else
+   if (_config->FindB("RPM::NoDeps", false) == false) {
 #if RPM_VERSION < 0x040000
-   rpmDependencyConflict *conflicts;
+      rpmDependencyConflict *conflicts = NULL;
 #else
-   rpmDependencyConflict conflicts;
+      rpmDependencyConflict conflicts = NULL;
 #endif
-   if (_config->FindB("RPM::NoDeps", false) == false) {
       int numConflicts;
-      if (rpmdepCheck(TS, &conflicts, &numConflicts)) {
+      if (rpmdepCheck(TS, &conflicts, &numConflicts) || conflicts) {
 	 _error->Error(_("Transaction set check failed"));
 	 if (conflicts) {
 	    printDepProblems(stderr, conflicts, numConflicts);
@@ -860,10 +899,10 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
 
    rc = 0;
 #if RPM_VERSION >= 0x040100
-   if (_config->FindB("RPM::Order", false) == true)
+   if (_config->FindB("RPM::Order", true) == true)
       rc = rpmtsOrder(TS);
 #else
-   if (_config->FindB("RPM::Order", false) == true)
+   if (_config->FindB("RPM::Order", true) == true)
       rc = rpmdepOrder(TS);
 #endif
 
@@ -872,6 +911,7 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
       goto exit;
    }
 
+   if (quiet <= 2)
    cout << _("Committing changes...") << endl << flush;
 
 #if RPM_VERSION >= 0x040100
@@ -891,11 +931,11 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
       _error->Error(_("Error while running transaction"));
       if (probs->numProblems > 0)
 	 rpmpsPrint(stderr, probs);
+   } else if (rc < 0) {
+      _error->Error(_("Some errors occurred while running transaction"));
    } else {
       Success = true;
-      if (rc < 0)
-	 _error->Warning(_("Some errors occurred while running transaction"));
-      else if (Interactive == true)
+      if (quiet <= 2)
 	 cout << _("Done.") << endl;
    }
    rpmpsFree(probs);
@@ -939,8 +979,6 @@ bool pkgRPMLibPM::ParseRpmOpts(const char *Cnf, int *tsFlags, int *probFilter)
 #if RPM_VERSION >= 0x040000
 	 else if (Opts->Value == "--nomd5")
 	    *tsFlags |= RPMTRANS_FLAG_NOMD5;
-	 else if (Opts->Value == "--repackage")
-	    *tsFlags |= RPMTRANS_FLAG_REPACKAGE;
 #endif
 #if RPM_VERSION >= 0x040200
 	 else if (Opts->Value == "--noconfigs" ||
diff --git a/apt-pkg/rpm/rpmrecords.cc b/apt-pkg/rpm/rpmrecords.cc
index 6f8f270..dd3a055 100644
--- a/apt-pkg/rpm/rpmrecords.cc
+++ b/apt-pkg/rpm/rpmrecords.cc
@@ -25,6 +25,8 @@
 
 #include <apti18n.h>
 
+#include <cstring>
+
 // RecordParser::rpmRecordParser - Constructor				/*{{{*/
 // ---------------------------------------------------------------------
 /* */
@@ -171,6 +173,27 @@ string rpmRecordParser::LongDesc()
    return Ret;
 }
 									/*}}}*/
+// RecordParser::Changelog - Return package changelog if any		/*{{{*/
+// -----------------------------------------------
+string rpmRecordParser::Changelog()
+{
+   char *str;
+   string rval("");
+
+   str = headerSprintf(HeaderP,
+         "[* %{CHANGELOGTIME:day} %{CHANGELOGNAME}\n%{CHANGELOGTEXT}\n\n]",
+         rpmTagTable, rpmHeaderFormats, NULL);
+
+   if (str && *str) {
+	  rval = (const char *)str;
+   }
+   if (str)
+      str = (char *)_free(str);
+
+   return rval;
+}
+
+									/*}}}*/
 // RecordParser::SourcePkg - Return the source package name if any	/*{{{*/
 // ---------------------------------------------------------------------
 /* */
@@ -178,7 +201,12 @@ string rpmRecordParser::SourcePkg()
 {
    // This must be the *package* name, not the *file* name. We have no
    // current way to extract it safely from the file name.
-   return "";
+   char *str;
+   int_32 count, type;
+   assert(HeaderP != NULL);
+   int rc = headerGetEntry(HeaderP, RPMTAG_SOURCERPM,
+			   &type, (void**)&str, &count);
+   return string(rc?str:"");
 }
 									/*}}}*/
 
@@ -192,20 +220,22 @@ void rpmRecordParser::BufCat(const char *begin, const char *end)
 {
    unsigned len = end - begin;
     
-   if (BufUsed+len+1 >= BufSize)
+   while (BufUsed + len + 1 >= BufSize)
    {
-      BufSize += 512;
-      char *tmp = (char*)realloc(Buffer, BufSize);
-      if (tmp == NULL)
+      size_t new_size = BufSize + 512;
+      char *new_buf = (char*)realloc(Buffer, new_size);
+      if (new_buf == NULL)
       {
 	 _error->Errno("realloc", _("Could not allocate buffer for record text"));
 	 return;
       }
-      Buffer = tmp;
+      Buffer = new_buf;
+      BufSize = new_size;
    }
 
-   strncpy(Buffer+BufUsed, begin, len);
+   memcpy(Buffer+BufUsed, begin, len);
    BufUsed += len;
+   Buffer[BufUsed] = '\0';
 }
 
 void rpmRecordParser::BufCatTag(const char *tag, const char *value)
@@ -256,20 +286,23 @@ void rpmRecordParser::BufCatDep(const char *pkg,
 void rpmRecordParser::BufCatDescr(const char *descr)
 {
    const char *begin = descr;
+   const char *p = descr;
 
-   while (*descr) 
+   while (*p)
    {
-      if (*descr=='\n') 
+      if (*p=='\n')
       {
 	 BufCat(" ");
-	 BufCat(begin, descr+1);
-	 begin = descr+1;
+	 BufCat(begin, p+1);
+	 begin = p+1;
       }
-      descr++;
+      p++;
+   }
+   if (*begin) {
+      BufCat(" ");
+      BufCat(begin, p);
+      BufCat("\n");
    }
-   BufCat(" ");
-   BufCat(begin, descr);
-   BufCat("\n");
 }
 
 
@@ -407,7 +440,7 @@ void rpmRecordParser::GetRec(const char *&Start,const char *&Stop)
    headerGetEntry(HeaderP, RPMTAG_ARCH, &type, (void **)&str, &count);
    BufCatTag("\nArchitecture: ", str);
    
-   snprintf(buf, sizeof(buf), "%d", Handler->FileSize());
+   snprintf(buf, sizeof(buf), "%lu", Handler->FileSize());
    BufCatTag("\nSize: ", buf);
 
    BufCatTag("\nMD5Sum: ", Handler->MD5Sum().c_str());
@@ -419,6 +452,17 @@ void rpmRecordParser::GetRec(const char *&Start,const char *&Stop)
    BufCat("\n");
    headerGetEntry(HeaderP, RPMTAG_DESCRIPTION, &type, (void **)&str, &count);
    BufCatDescr(str);
+
+   str = headerSprintf(HeaderP,
+         "[* %{CHANGELOGTIME:day} %{CHANGELOGNAME}\n%{CHANGELOGTEXT}\n]",
+         rpmTagTable, rpmHeaderFormats, NULL);
+   if (str && *str) {
+      BufCat("Changelog:\n");
+      BufCatDescr(str);
+   }
+   if (str)
+      str = (char *)_free(str);
+
    BufCat("\n");
    
    Start = Buffer;
diff --git a/apt-pkg/rpm/rpmrecords.h b/apt-pkg/rpm/rpmrecords.h
index 71e3325..d8a72d5 100644
--- a/apt-pkg/rpm/rpmrecords.h
+++ b/apt-pkg/rpm/rpmrecords.h
@@ -59,6 +59,7 @@ class rpmRecordParser : public pkgRecords::Parser
    virtual string ShortDesc();
    virtual string LongDesc();
    virtual string Name();
+   virtual string Changelog();
    
    inline Header GetRecord() { return HeaderP; };
 
diff --git a/apt-pkg/rpm/rpmsrcrecords.cc b/apt-pkg/rpm/rpmsrcrecords.cc
index 49256d4..4c9b36f 100644
--- a/apt-pkg/rpm/rpmsrcrecords.cc
+++ b/apt-pkg/rpm/rpmsrcrecords.cc
@@ -123,6 +123,20 @@ bool rpmSrcRecordParser::Jump(unsigned long Off)
    return true;
 }
 
+// RecordParser::FileName - Return the archive filename on the site	/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+string rpmSrcRecordParser::FileName() const
+{
+   char *str;
+   int_32 count, type;
+   assert(HeaderP != NULL);
+   int rc = headerGetEntry(HeaderP, CRPMTAG_FILENAME,
+			   &type, (void**)&str, &count);
+   return string(rc?str:"");
+}
+									/*}}}*/
+
 string rpmSrcRecordParser::Package() const
 {
    char *str;
@@ -191,44 +205,68 @@ string rpmSrcRecordParser::Section() const
    return string(rc?str:"");
 }
 
+// SrcRecordParser::Changelog - Package changelog
+// ----------------------------------------------
+string rpmSrcRecordParser::Changelog() const
+{
+   char *str;
+   string rval("");
+
+   str = headerSprintf(HeaderP,
+         "[* %{CHANGELOGTIME:day} %{CHANGELOGNAME}\n%{CHANGELOGTEXT}\n\n]",
+         rpmTagTable, rpmHeaderFormats, NULL);
+
+   if (str && *str) {
+	  rval = (const char *)str;
+   }
+   if (str)
+      str = (char *)_free(str);
+
+   return rval;
+}
+
 unsigned long rpmSrcRecordParser::Offset() 
 {
     return Handler->Offset();
 }
 
-void rpmSrcRecordParser::BufCat(char *text)
+void rpmSrcRecordParser::BufCat(const char *text)
 {
    if (text != NULL)
       BufCat(text, text+strlen(text));
 }
 
-void rpmSrcRecordParser::BufCat(char *begin, char *end)
+void rpmSrcRecordParser::BufCat(const char *begin, const char *end)
 {
    unsigned len = end - begin;
     
-   if (BufUsed+len+1 >= BufSize)
+   while (BufUsed + len + 1 >= BufSize)
    {
-      BufSize += 512;
-      char *tmp = (char*)realloc(Buffer, BufSize);
-      if (tmp == NULL)
+      size_t new_size = BufSize + 512;
+      char *new_buf = (char*)realloc(Buffer, new_size);
+      if (new_buf == NULL)
       {
 	 _error->Errno("realloc", _("Could not allocate buffer for record text"));
 	 return;
       }
-      Buffer = tmp;
+      Buffer = new_buf;
+      BufSize = new_size;
    }
 
-   strncpy(Buffer+BufUsed, begin, len);
+   memcpy(Buffer+BufUsed, begin, len);
    BufUsed += len;
+   Buffer[BufUsed] = '\0';
 }
 
-void rpmSrcRecordParser::BufCatTag(char *tag, char *value)
+void rpmSrcRecordParser::BufCatTag(const char *tag, const char *value)
 {
    BufCat(tag);
    BufCat(value);
 }
 
-void rpmSrcRecordParser::BufCatDep(char *pkg, char *version, int flags)
+void rpmSrcRecordParser::BufCatDep(const char *pkg,
+				   const char *version,
+				   int flags)
 {
    char buf[16];
    char *ptr = (char*)buf;
@@ -265,23 +303,26 @@ void rpmSrcRecordParser::BufCatDep(char *pkg, char *version, int flags)
    }
 }
 
-void rpmSrcRecordParser::BufCatDescr(char *descr)
+void rpmSrcRecordParser::BufCatDescr(const char *descr)
 {
-   char *begin = descr;
+   const char *begin = descr;
+   const char *p = descr;
 
-   while (*descr) 
+   while (*p)
    {
-      if (*descr=='\n') 
+      if (*p=='\n')
       {
 	 BufCat(" ");
-	 BufCat(begin, descr+1);
-	 begin = descr+1;
+	 BufCat(begin, p+1);
+	 begin = p+1;
       }
-      descr++;
+      p++;
+   }
+   if (*begin) {
+      BufCat(" ");
+      BufCat(begin, p);
+      BufCat("\n");
    }
-   BufCat(" ");
-   BufCat(begin, descr);
-   BufCat("\n");
 }
 
 // SrcRecordParser::AsStr - The record in raw text
@@ -394,6 +435,17 @@ string rpmSrcRecordParser::AsStr()
    BufCat("\n");
    headerGetEntry(HeaderP, RPMTAG_DESCRIPTION, &type, (void **)&str, &count);
    BufCatDescr(str);
+
+   str = headerSprintf(HeaderP,
+         "[* %{CHANGELOGTIME:day} %{CHANGELOGNAME}\n%{CHANGELOGTEXT}\n]",
+         rpmTagTable, rpmHeaderFormats, NULL);
+   if (str && *str) {
+      BufCat("Changelog:\n");
+      BufCatDescr(str);
+   }
+   if (str)
+      str = (char *)_free(str);
+
    BufCat("\n");
    
    return string(Buffer, BufUsed);
diff --git a/apt-pkg/rpm/rpmsrcrecords.h b/apt-pkg/rpm/rpmsrcrecords.h
index 2e8f691..2b1cd04 100644
--- a/apt-pkg/rpm/rpmsrcrecords.h
+++ b/apt-pkg/rpm/rpmsrcrecords.h
@@ -33,21 +33,24 @@ class rpmSrcRecordParser : public pkgSrcRecords::Parser
    unsigned int BufSize;
    unsigned int BufUsed;
    
-   void BufCat(char *text);
-   void BufCat(char *begin, char *end);
-   void BufCatTag(char *tag, char *value);
-   void BufCatDep(char *pkg, char *version, int flags);
-   void BufCatDescr(char *descr);
+   void BufCat(const char *text);
+   void BufCat(const char *begin, const char *end);
+   void BufCatTag(const char *tag, const char *value);
+   void BufCatDep(const char *pkg, const char *version, int flags);
+   void BufCatDescr(const char *descr);
 
 public:
    virtual bool Restart();
    virtual bool Step(); 
    virtual bool Jump(unsigned long Off);
 
+   virtual string FileName() const;
+
    virtual string Package() const;
    virtual string Version() const;
    virtual string Maintainer() const;
    virtual string Section() const;
+   virtual string Changelog() const;
    virtual const char **Binaries();
    virtual unsigned long Offset();
    virtual string AsStr();
diff --git a/apt-pkg/rpm/rpmsystem.cc b/apt-pkg/rpm/rpmsystem.cc
index 69169c7..f4215d5 100644
--- a/apt-pkg/rpm/rpmsystem.cc
+++ b/apt-pkg/rpm/rpmsystem.cc
@@ -136,13 +136,13 @@ pkgPackageManager *rpmSystem::CreatePM(pkgDepCache *Cache) const
 bool rpmSystem::Initialize(Configuration &Cnf)
 {
    Cnf.CndSet("Dir::Bin::rpm","/bin/rpm");
-   Cnf.CndSet("Dir::Etc::rpmpriorities", "rpmpriorities");
+   Cnf.CndSet("Dir::Etc::pkgpriorities", "pkgpriorities");
    Cnf.CndSet("Dir::Etc::translatelist", "translate.list");
    Cnf.CndSet("Dir::Etc::translateparts", "translate.list.d");
    Cnf.CndSet("Dir::State::prefetch", "prefetch");
    Cnf.CndSet("Dir::Locale","/usr/share/locale");
-   Cnf.CndSet("Acquire::DistroID","Conectiva"); // hee hee
-   Cnf.CndSet("Acquire::CDROM::Mount", "/mnt/cdrom");
+   Cnf.CndSet("Acquire::DistroID","ALT Linux"); // hee hee
+   Cnf.CndSet("Acquire::CDROM::Mount", "/media/ALTLinux");
    Cnf.CndSet("Acquire::CDROM::Copy-All", "true");
 
    // Compatibility with obsoleted options
@@ -248,31 +248,50 @@ signed rpmSystem::Score(Configuration const &Cnf)
 string rpmSystem::DistroVer(Configuration const &Cnf)
 {
    string DistroVerPkg = _config->Find("Apt::DistroVerPkg");
-   string DistroVersion = "";
-
-
-   if (! DistroVerPkg.empty()) {
-      rpmts ts;
-      char *version;
-      int type, count, rc;
-      rpmdbMatchIterator iter;
+   string DistroVersion;
+
+   if (DistroVerPkg.empty())
+      return DistroVersion;
+
+#if RPM_VERSION >= 0x040100
+   rpmts ts;
+   ts = rpmtsCreate();
+   rpmtsSetVSFlags(ts, (rpmVSFlags_e)-1);
+   rpmtsSetRootDir(ts, NULL);
+   if (rpmtsOpenDB(ts, O_RDONLY))
+      return DistroVersion;
+#else
+   rpmdb DB;
+   string RootDir = _config->Find("RPM::RootDir");
+   const char *RootDirStr = RootDir.empty() ? NULL : RootDir.c_str();
+   if (rpmdbOpen(RootDirStr, &DB, O_RDONLY, 0644))
+      return DistroVersion;
+#endif
 
-      ts = rpmtsCreate();
-      rpmtsSetVSFlags(ts, (rpmVSFlags_e)-1);
-      rpmtsSetRootDir(ts, NULL);
-      rc = rpmtsOpenDB(ts, O_RDWR);
+   rpmdbMatchIterator iter;
+#if RPM_VERSION >= 0x040100
+   iter = rpmtsInitIterator(ts, (rpmTag)RPMDBI_LABEL, DistroVerPkg.c_str(), 0);
+#else
+   iter = rpmdbInitIterator(DB, RPMDBI_LABEL, DistroVerPkg.c_str(), 0);
+#endif
+   Header hdr;
+   while ((hdr = rpmdbNextIterator(iter)) != NULL) {
+      void *version;
+      int type, count;
 
-      Header hdr;
-      iter = rpmtsInitIterator(ts, (rpmTag)RPMDBI_LABEL, DistroVerPkg.c_str(), 0);
-      while ((hdr = rpmdbNextIterator(iter)) != NULL) {
-         headerGetEntry(hdr, RPMTAG_VERSION, &type, (void **)&version, &count);
-	 DistroVersion = version;
+      if (headerGetEntry(hdr, RPMTAG_VERSION, &type, &version, &count)) {
+         DistroVersion = (char *)version;
+         headerFreeData(&version, (rpmTagType)type);
          break;
       }
-      rpmdbFreeIterator(iter);
-      rpmtsFree(ts);
    }
-   
+   rpmdbFreeIterator(iter);
+#if RPM_VERSION >= 0x040100
+   rpmtsFree(ts);
+#else
+   rpmdbClose(DB);
+#endif
+
    return DistroVersion;
 }
 
@@ -291,7 +310,7 @@ bool rpmSystem::AddStatusFiles(vector<pkgIndexFile *> &List)
 // System::AddSourceFiles - Register aditional source files		/*{{{*/
 // ---------------------------------------------------------------------
 /* */
-bool rpmSystem::AddSourceFiles(vector<pkgIndexFile *> &List)
+void rpmSystem::AddSourceFiles(vector<pkgIndexFile *> &List)
 {
    const Configuration::Item *Top;
    Top = _config->Tree("APT::Arguments");
@@ -308,7 +327,6 @@ bool rpmSystem::AddSourceFiles(vector<pkgIndexFile *> &List)
 	 }
       }
    }
-   return true;
 }
 									/*}}}*/
 #ifdef OLD_FILEDEPS
@@ -574,11 +592,14 @@ static void HashOptionFile(unsigned long &Hash, const char *Name)
 unsigned long rpmSystem::OptionsHash() const
 {
    unsigned long Hash = 0;
+#ifdef PKG_NEVRA
+   HashString(Hash, PKG_NEVRA);
+#endif
    HashOption(Hash, "RPM::Architecture");
    HashOptionTree(Hash, "RPM::Allow-Duplicated");
    HashOptionTree(Hash, "RPM::MultiArch");
    HashOptionTree(Hash, "RPM::Ignore");
-   HashOptionFile(Hash, "Dir::Etc::rpmpriorities");
+   HashOptionFile(Hash, "Dir::Etc::pkgpriorities");
    HashEnv(Hash, "LANG");
    HashEnv(Hash, "LC_ALL");
    HashEnv(Hash, "LC_MESSAGES");
diff --git a/apt-pkg/rpm/rpmsystem.h b/apt-pkg/rpm/rpmsystem.h
index 358b7c4..59acf56 100644
--- a/apt-pkg/rpm/rpmsystem.h
+++ b/apt-pkg/rpm/rpmsystem.h
@@ -61,7 +61,7 @@ class rpmSystem : public pkgSystem
    virtual signed Score(Configuration const &Cnf);
    virtual string DistroVer(Configuration const &Cnf);
    virtual bool AddStatusFiles(vector<pkgIndexFile *> &List);
-   virtual bool AddSourceFiles(vector<pkgIndexFile *> &List);
+   virtual void AddSourceFiles(vector<pkgIndexFile *> &List);
    virtual bool FindIndex(pkgCache::PkgFileIterator File,
 			  pkgIndexFile *&Found) const;
    virtual bool ProcessCache(pkgDepCache &Cache,pkgProblemResolver &Fix);
diff --git a/apt-pkg/rpm/rpmversion.cc b/apt-pkg/rpm/rpmversion.cc
index d3f5efd..d335b74 100644
--- a/apt-pkg/rpm/rpmversion.cc
+++ b/apt-pkg/rpm/rpmversion.cc
@@ -194,10 +194,19 @@ bool rpmVersioningSystem::CheckDep(const char *PkgVer,
       break;
       
     default:
+      // optimize: no need to check version
+      return true;
+      // old code:
       DepFlags = RPMSENSE_ANY;
       break;
    }
 
+   // optimize: equal version strings => equal versions
+   if ((DepFlags & RPMSENSE_SENSEMASK) == RPMSENSE_EQUAL)
+      if (PkgVer && DepVer)
+	 if (strcmp(PkgVer, DepVer) == 0)
+	    return invert ? false : true;
+
 #if RPM_VERSION >= 0x040100
    rpmds pds = rpmdsSingle(RPMTAG_PROVIDENAME, "", PkgVer, PkgFlags);
    rpmds dds = rpmdsSingle(RPMTAG_REQUIRENAME, "", DepVer, DepFlags);
diff --git a/apt-pkg/sourcelist.cc b/apt-pkg/sourcelist.cc
index 326791a..2528573 100644
--- a/apt-pkg/sourcelist.cc
+++ b/apt-pkg/sourcelist.cc
@@ -12,6 +12,8 @@
 #pragma implementation "apt-pkg/sourcelist.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/sourcelist.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/fileutl.h>
@@ -150,7 +152,7 @@ pkgSourceList::~pkgSourceList()
 {
    for (const_iterator I = SrcList.begin(); I != SrcList.end(); I++)
       delete *I;
-   for (vector<Vendor const *>::const_iterator I = VendorList.begin(); 
+   for (vector<Vendor *>::iterator I = VendorList.begin(); 
 	I != VendorList.end(); I++)
       delete *I;
 }
@@ -174,38 +176,54 @@ bool pkgSourceList::ReadVendors()
       if (ReadConfigFile(Cnf,CnfFile,true) == false)
 	 return false;
 
-   for (vector<Vendor const *>::const_iterator I = VendorList.begin(); 
+   for (vector<Vendor *>::iterator I = VendorList.begin(); 
 	I != VendorList.end(); I++)
       delete *I;
    VendorList.erase(VendorList.begin(),VendorList.end());
-   
+
    // Process 'simple-key' type sections
    const Configuration::Item *Top = Cnf.Tree("simple-key");
    for (Top = (Top == 0?0:Top->Child); Top != 0; Top = Top->Next)
    {
       Configuration Block(Top);
-      Vendor *Vendor;
+      Vendor *Vendor = 0;
+      string Group = Block.Find("Group");
+      bool New = true;
       
-      Vendor = new pkgSourceList::Vendor;
-      
-      Vendor->VendorID = Top->Tag;
-      Vendor->FingerPrint = Block.Find("Fingerprint");
-      Vendor->Description = Block.Find("Name");
+      for (vector<pkgSourceList::Vendor *>::iterator I = VendorList.begin(); 
+	   I != VendorList.end(); I++)
+      {
+        if ((*I)->VendorID == Group)
+	{
+	  Vendor = *I;
+	  New = false;
+	  break;
+	}
+      }
+
+      if (!Vendor)
+      {
+        Vendor = new pkgSourceList::Vendor;
+
+        Vendor->Description = Block.Find("Name");
+        Vendor->VendorID = Top->Tag;
+      }
+      string FingerPrint = Block.Find("Fingerprint");
 
       // CNC:2002-08-15
-      char *buffer = new char[Vendor->FingerPrint.length()+1];
+      char *buffer = new char[FingerPrint.length()+1];
       char *p = buffer;;
-      for (string::const_iterator I = Vendor->FingerPrint.begin();
-	   I != Vendor->FingerPrint.end(); I++)
+      for (string::const_iterator I = FingerPrint.begin();
+	   I != FingerPrint.end(); I++)
       {
 	 if (*I != ' ' && *I != '\t')
 	    *p++ = *I;
       }
       *p = 0;
-      Vendor->FingerPrint = buffer;
+      Vendor->FingerPrint.push_back(string(buffer));
       delete [] buffer;
       
-      if (Vendor->FingerPrint.empty() == true || 
+      if (Vendor->FingerPrint.size() == 0 || 
 	  Vendor->Description.empty() == true)
       {
          _error->Error(_("Vendor block %s is invalid"), Vendor->VendorID.c_str());
@@ -213,7 +231,8 @@ bool pkgSourceList::ReadVendors()
 	 continue;
       }
       
-      VendorList.push_back(Vendor);
+      if (New)
+         VendorList.push_back(Vendor);
    }
 
    /* XXX Process 'group-key' type sections
@@ -355,7 +374,7 @@ bool pkgSourceList::ReadAppend(string File)
 	     return _error->Error(_("Malformed line %u in source list %s (vendor id)"),CurLine,File.c_str());
 	 VendorID = string(VendorID,1,VendorID.size()-2);
 	 
-	 for (vector<Vendor const *>::const_iterator iter = VendorList.begin();
+	 for (vector<Vendor *>::iterator iter = VendorList.begin();
 	      iter != VendorList.end(); iter++) 
 	 {
 	    if ((*iter)->VendorID == VendorID)
diff --git a/apt-pkg/sourcelist.h b/apt-pkg/sourcelist.h
index e010bc0..a4174fe 100644
--- a/apt-pkg/sourcelist.h
+++ b/apt-pkg/sourcelist.h
@@ -48,7 +48,7 @@ class pkgSourceList
    struct Vendor
    {
       string VendorID;
-      string FingerPrint;
+      vector<string> FingerPrint;
       string Description;
 
       /* Lets revisit these..
@@ -87,8 +87,8 @@ class pkgSourceList
    protected:
 
    vector<pkgIndexFile *> SrcList;
-   vector<Vendor const *> VendorList;
-   
+   vector<Vendor *> VendorList;
+
    public:
 
    bool ReadMainList();
diff --git a/apt-pkg/srcrecords.cc b/apt-pkg/srcrecords.cc
index e0901e3..b7544de 100644
--- a/apt-pkg/srcrecords.cc
+++ b/apt-pkg/srcrecords.cc
@@ -15,6 +15,8 @@
 #pragma implementation "apt-pkg/srcrecords.h"
 #endif 
 
+#include <config.h>
+
 #include <apt-pkg/srcrecords.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/sourcelist.h>
@@ -82,7 +84,7 @@ bool pkgSrcRecords::Restart()
 									/*}}}*/
 // SrcRecords::Find - Find the first source package with the given name	/*{{{*/
 // ---------------------------------------------------------------------
-/* This searches on both source package names and output binary names and
+/* This searches on both source package filenames and output binary names and
    returns the first found. A 'cursor' like system is used to allow this
    function to be called multiple times to get successive entries */
 pkgSrcRecords::Parser *pkgSrcRecords::Find(const char *Package,bool SrcOnly)
@@ -92,6 +94,8 @@ pkgSrcRecords::Parser *pkgSrcRecords::Find(const char *Package,bool SrcOnly)
    
    while (true)
    {
+      // DEBUG:
+      //std::cerr << "start loop" << std::endl;
       // Step to the next record, possibly switching files
       while ((*Current)->Step() == false)
       {
@@ -107,7 +111,7 @@ pkgSrcRecords::Parser *pkgSrcRecords::Find(const char *Package,bool SrcOnly)
 	 return 0;
 
       // Source name hit
-      if ((*Current)->Package() == Package)
+      if ((*Current)->FileName() == Package)
 	 return *Current;
       
 
diff --git a/apt-pkg/srcrecords.h b/apt-pkg/srcrecords.h
index 006c9d3..bb8880e 100644
--- a/apt-pkg/srcrecords.h
+++ b/apt-pkg/srcrecords.h
@@ -66,10 +66,13 @@ class pkgSrcRecords
       virtual unsigned long Offset() = 0;
       virtual string AsStr() = 0;
       
+      virtual string FileName() const = 0;
+
       virtual string Package() const = 0;
       virtual string Version() const = 0;
       virtual string Maintainer() const = 0;
       virtual string Section() const = 0;
+      virtual string Changelog() const = 0;
       virtual const char **Binaries() = 0;   // Ownership does not transfer
 
       virtual bool BuildDepends(vector<BuildDepRec> &BuildDeps, bool ArchOnly) = 0;
diff --git a/apt-pkg/tagfile.cc b/apt-pkg/tagfile.cc
index 5443b17..4d4ae85 100644
--- a/apt-pkg/tagfile.cc
+++ b/apt-pkg/tagfile.cc
@@ -15,6 +15,8 @@
 #pragma implementation "apt-pkg/tagfile.h"
 #endif
 
+#include <config.h>
+
 #include <apt-pkg/tagfile.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/strutl.h>
diff --git a/apt-pkg/version.cc b/apt-pkg/version.cc
index 126e63a..8254f9e 100644
--- a/apt-pkg/version.cc
+++ b/apt-pkg/version.cc
@@ -12,6 +12,8 @@
 #pragma implementation "apt-pkg/version.h"
 #endif 
 
+#include <config.h>
+
 #include <apt-pkg/version.h>
 #include <apt-pkg/pkgcache.h>
 
diff --git a/apt-pkg/versionmatch.cc b/apt-pkg/versionmatch.cc
index d8a2bff..e50f16d 100644
--- a/apt-pkg/versionmatch.cc
+++ b/apt-pkg/versionmatch.cc
@@ -14,6 +14,8 @@
 #ifdef __GNUG__
 #pragma implementation "apt-pkg/versionmatch.h"
 #endif
+#include <config.h>
+
 #include <apt-pkg/versionmatch.h>
 // CNC:2003-11-05
 #include <apt-pkg/version.h>
@@ -164,11 +166,12 @@ bool pkgVersionMatch::MatchVer(const char *A,string B,bool Prefix)
 // VersionMatch::Find - Locate the best match for the select type	/*{{{*/
 // ---------------------------------------------------------------------
 /* */
-pkgCache::VerIterator pkgVersionMatch::Find(pkgCache::PkgIterator Pkg)
+std::list<pkgCache::VerIterator> pkgVersionMatch::FindAll(pkgCache::PkgIterator Pkg)
 {
    // CNC:2003-11-05
    pkgVersioningSystem *VS = Pkg.Cache()->VS;
    pkgCache::VerIterator Ver = Pkg.VersionList();
+   std::list<pkgCache::VerIterator> found;
 
    for (; Ver.end() == false; Ver++)
    {
@@ -178,10 +181,10 @@ pkgCache::VerIterator pkgVersionMatch::Find(pkgCache::PkgIterator Pkg)
          if (VerPrefixMatch)
 	 {
 	    if (MatchVer(Ver.VerStr(),VerStr,VerPrefixMatch) == true)
-	       return Ver;
+	       found.push_back(Ver);
 	 } else {
 	    if (VS->CheckDep(Ver.VerStr(),VerOp,VerStr.c_str()) == true)
-	       return Ver;
+	       found.push_back(Ver);
 	 }
 
 	 continue;
@@ -189,8 +192,11 @@ pkgCache::VerIterator pkgVersionMatch::Find(pkgCache::PkgIterator Pkg)
       
       for (pkgCache::VerFileIterator VF = Ver.FileList(); VF.end() == false; VF++)
 	 if (FileMatch(VF.File()) == true)
-	    return Ver;
+	    found.push_back(Ver);
    }
+
+   if (found.size() > 0)
+      goto done;
       
    // CNC:2003-11-11 - Virtual package handling.
    if (Type == Version)
@@ -205,15 +211,28 @@ pkgCache::VerIterator pkgVersionMatch::Find(pkgCache::PkgIterator Pkg)
          if (VerPrefixMatch || (HasRelease && strchr(PrvVerStr, '-') == NULL))
          {
             if (MatchVer(PrvVerStr,VerStr,VerPrefixMatch) == true)
-               return Prv.OwnerVer();
+               found.push_back(Prv.OwnerVer());
          } else {
             if (VS->CheckDep(PrvVerStr,VerOp,VerStr.c_str()) == true)
-               return Prv.OwnerVer();
+               found.push_back(Prv.OwnerVer());
          }
       }
    }
 
-   // This will be Ended by now.
+done:
+   return found;
+}
+
+pkgCache::VerIterator pkgVersionMatch::Find(pkgCache::PkgIterator Pkg)
+{
+   std::list<pkgCache::VerIterator> found = FindAll(Pkg);
+   if (found.size() > 0)
+      return found.front();
+
+   // return "empty" iterator at its end
+   pkgCache::VerIterator Ver = Pkg.VersionList();
+   while (Ver.end() == false)
+      Ver++;
    return Ver;
 }
 									/*}}}*/
diff --git a/apt-pkg/versionmatch.h b/apt-pkg/versionmatch.h
index ce80c79..9efb893 100644
--- a/apt-pkg/versionmatch.h
+++ b/apt-pkg/versionmatch.h
@@ -36,6 +36,7 @@
 #endif
 
 #include <string>
+#include <list>
 #include <apt-pkg/pkgcache.h>
 
 using std::string;
@@ -70,6 +71,7 @@ class pkgVersionMatch
 			       
    // CNC:2003-11-05
    pkgVersionMatch(string Data,MatchType Type,int Op=pkgCache::Dep::Equals);
+   std::list<pkgCache::VerIterator> FindAll(pkgCache::PkgIterator Pkg);
 };
 
 #endif
diff --git a/buildlib/archtable b/buildlib/archtable
index 810f444..2cd27f7 100644
--- a/buildlib/archtable
+++ b/buildlib/archtable
@@ -5,8 +5,10 @@
 
 # The left side is a regex for awk
 
-i.86	i386
-pentium	i386
+i[34]86	i386
+i.86	i586
+pentium.*	i586
+athlon	i586
 sparc	sparc
 sparc64	sparc
 alpha.*	alpha
@@ -25,3 +27,5 @@ ia64	ia64
 s390	s390
 s390x	s390x
 x86_64	x86_64
+aarch64	aarch64
+e2k	e2k
diff --git a/buildlib/tools.m4 b/buildlib/tools.m4
index 21ac652..2b2e41a 100644
--- a/buildlib/tools.m4
+++ b/buildlib/tools.m4
@@ -96,11 +96,15 @@ AC_DEFUN([rc_GLIBC_VER],
 #include <features.h>
 #include <stdio.h>
 #include <stdlib.h>
-int main(int argc, char **argv) { printf("libc6.%d",__GLIBC_MINOR__); exit(0); }
+int main(int argc, char **argv) { printf("%d",__GLIBC_MINOR__); exit(0); }
 _GLIBC_
 	${CC-cc} $dummy.c -o $dummy > /dev/null 2>&1
 	if test "$?" = 0; then
-		GLIBC_VER=`./$dummy`
+		GLIBC_MINOR=`./$dummy`
+		if test "$GLIBC_MINOR" -gt 9; then
+			GLIBC_MINOR=9
+		fi
+		GLIBC_VER="libc6.$GLIBC_MINOR"
 		AC_MSG_RESULT([$GLIBC_VER])
 		dnl CNC:2003-03-25
 		GLIBC_VER="$GLIBC_VER"
@@ -115,16 +119,13 @@ AC_DEFUN([rc_LIBSTDCPP_VER],
 	[AC_MSG_CHECKING([libstdc++ version])
 	dummy=if$$
 	cat <<_LIBSTDCPP_>$dummy.cc
-#include <features.h>
-#include <stdio.h>
-#include <stdlib.h>
-int main(int argc, char **argv) { exit(0); }
+#include <iostream>
+int main(void) { std::cout << std::endl; return 0; }
 _LIBSTDCPP_
 	${CXX-c++} $dummy.cc -o $dummy > /dev/null 2>&1
 
 	if test "$?" = 0; then
-		soname=`objdump -p ./$dummy |grep NEEDED|grep libstd`
-                LIBSTDCPP_VER=`echo $soname | sed -e 's/.*NEEDED.*libstdc++\(-libc.*\(-.*\)\)\?.so.\(.*\)/\3\2/'`
+                LIBSTDCPP_VER=`objdump -p ./$dummy | sed -ne 's/.*NEEDED.*libstdc++\(-libc.*\(-.*\)\)\?.so.\(.*\)/\3\2/p'`
 	fi
 	rm -f $dummy $dummy.cc
 
diff --git a/cmdline/Makefile.am b/cmdline/Makefile.am
index 0bdf11d..b6e7967 100644
--- a/cmdline/Makefile.am
+++ b/cmdline/Makefile.am
@@ -4,7 +4,7 @@ EXTRA_DIST = indexcopy.cc indexcopy.h
 bin_PROGRAMS = apt-get apt-cache apt-cdrom apt-config
 
 if COMPILE_APTSHELL
-bin_PROGRAMS += apt-shell
+bin_PROGRAMS += apt-shell apt-pipe
 endif
 if COMPILE_STATIC
 bin_PROGRAMS += apt-get-static apt-cache-static apt-cdrom-static
@@ -15,7 +15,10 @@ LDADD = ../apt-pkg/libapt-pkg.la $(RPMLIBS)
 apt_get_SOURCES = apt-get.cc acqprogress.cc acqprogress.h
 apt_cache_SOURCES = apt-cache.cc
 apt_shell_SOURCES = apt-shell.cc acqprogress.cc acqprogress.h
-apt_shell_LDADD = $(LDADD) -lreadline -lncurses
+apt_shell_LDADD = $(LDADD) -lreadline
+apt_pipe_SOURCES = $(apt_shell_SOURCES) apt-pipe.c
+apt_pipe_CPPFLAGS = -DAPT_PIPE
+apt_pipe_LDADD = $(LDADD) -lsetproctitle
 apt_config_SOURCES = apt-config.cc
 apt_cdrom_SOURCES = apt-cdrom.cc rpmindexcopy.cc rpmindexcopy.h
 
diff --git a/cmdline/Makefile.in b/cmdline/Makefile.in
index 4a54921..26a2eb2 100644
--- a/cmdline/Makefile.in
+++ b/cmdline/Makefile.in
@@ -289,7 +289,7 @@ LDADD = ../apt-pkg/libapt-pkg.la $(RPMLIBS)
 apt_get_SOURCES = apt-get.cc acqprogress.cc acqprogress.h
 apt_cache_SOURCES = apt-cache.cc
 apt_shell_SOURCES = apt-shell.cc acqprogress.cc acqprogress.h
-apt_shell_LDADD = $(LDADD) -lreadline -lncurses
+apt_shell_LDADD = $(LDADD) -lreadline
 apt_config_SOURCES = apt-config.cc
 apt_cdrom_SOURCES = apt-cdrom.cc rpmindexcopy.cc rpmindexcopy.h
 apt_get_static_SOURCES = $(apt_get_SOURCES)
diff --git a/cmdline/acqprogress.cc b/cmdline/acqprogress.cc
index 5a6198d..1fd8ce1 100644
--- a/cmdline/acqprogress.cc
+++ b/cmdline/acqprogress.cc
@@ -8,11 +8,14 @@
    ##################################################################### */
 									/*}}}*/
 // Include files							/*{{{*/
+#include <config.h>
+
 #include "acqprogress.h"
 #include <apt-pkg/acquire-item.h>
 #include <apt-pkg/acquire-worker.h>
 #include <apt-pkg/strutl.h>
 #include <apt-pkg/error.h>
+#include <apt-pkg/configuration.h>
 
 #include <apti18n.h>
     
@@ -270,10 +273,12 @@ bool AcqTextStatus::MediaChange(string Media,string Drive)
 {
    if (Quiet <= 0)
       cout << '\r' << BlankLine << '\r';
-   ioprintf(cout,_("Media Change: Please insert the disc labeled\n"
+   ioprintf(cout,_("Media Change: Please insert the media labeled\n"
 		   " '%s'\n"
-		   "in the drive '%s' and press enter\n"),
+		   "and press enter\n"),
 	    Media.c_str(),Drive.c_str());
+   if (_config->FindB("simple-output"))
+   	cout << "apt-get:media-change:" << Drive << ":" << Media << std::endl;
 
    char C = 0;
    while (C != '\n' && C != '\r')
diff --git a/cmdline/apt-cache.cc b/cmdline/apt-cache.cc
index 6240edc..cdb5edc 100644
--- a/cmdline/apt-cache.cc
+++ b/cmdline/apt-cache.cc
@@ -13,6 +13,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include <apt-pkg/error.h>
 #include <apt-pkg/pkgcachegen.h>
 #include <apt-pkg/init.h>
@@ -28,7 +30,6 @@
 #include <apt-pkg/algorithms.h>
 #include <apt-pkg/sptr.h>
 
-#include <config.h>
 #include <apti18n.h>
 
 // CNC:2003-02-14 - apti18n.h includes libintl.h which includes locale.h,
@@ -356,6 +357,7 @@ bool Dump(CommandLine &Cmd)
    pkgCache &Cache = *GCache;
    cout << "Using Versioning System: " << Cache.VS->Label << endl;
    
+   if (_config->FindB("APT::Cache::DumpPackages",true) == true)
    for (pkgCache::PkgIterator P = Cache.PkgBegin(); P.end() == false; P++)
    {
       cout << "Package: " << P.Name() << endl;
@@ -398,7 +400,7 @@ bool DumpAvail(CommandLine &Cmd)
    pkgCache &Cache = *GCache;
 
    pkgPolicy Plcy(&Cache);
-   if (ReadPinFile(Plcy) == false)
+   if (ReadPinFile(Plcy) == false || ReadPinDir(Plcy) == false)
       return false;
    
    unsigned long Count = Cache.HeaderP->PackageCount+1;
@@ -878,8 +880,7 @@ bool WhatDepends(CommandLine &CmdL)
 		  continue;
 	       LocalColours[Parent->ID] = 1;
 		  
-	       if (Ver.end() == false &&
-		   Cache.VS->CheckDep(Ver.VerStr(),RD) == false)
+	       if (Cache.VS->CheckDep(RDPrv.ProvideVersion(),RD) == false)
 		  continue;
 
 	       if (Recurse == true && Colours[Parent->ID] == 0)
@@ -1741,7 +1742,7 @@ bool Policy(CommandLine &CmdL)
    
    pkgCache &Cache = *GCache;
    pkgPolicy Plcy(&Cache);
-   if (ReadPinFile(Plcy) == false)
+   if (ReadPinFile(Plcy) == false || ReadPinDir(Plcy) == false)
       return false;
    
    // Print out all of the package files
@@ -1987,8 +1988,8 @@ int main(int argc,const char *argv[])
    // Parse the command line and initialize the package library
    CommandLine CmdL(Args,_config);
    if (pkgInitConfig(*_config) == false ||
-       CmdL.Parse(argc,argv) == false ||
-       pkgInitSystem(*_config,_system) == false)
+       pkgInitSystem(*_config,_system) == false ||
+       CmdL.Parse(argc,argv) == false)
    {
       _error->DumpErrors();
       return 100;
diff --git a/cmdline/apt-cdrom.cc b/cmdline/apt-cdrom.cc
index 0a993ca..ec99ddb 100644
--- a/cmdline/apt-cdrom.cc
+++ b/cmdline/apt-cdrom.cc
@@ -11,6 +11,7 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
 #include <apt-pkg/cmndline.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/init.h>
@@ -18,7 +19,6 @@
 #include <apt-pkg/progress.h>
 #include <apt-pkg/cdromutl.h>
 #include <apt-pkg/strutl.h>
-#include <config.h>
 #include <apti18n.h>
     
 // CNC:2002-07-11
@@ -568,7 +568,7 @@ bool DoAdd(CommandLine &)
    if (CDROM[0] == '.')
       CDROM= SafeGetCWD() + '/' + CDROM;
    
-   cout << _("Using CD-ROM mount point ") << CDROM << endl;
+   cout << _("Using Media mount point ") << CDROM << endl;
       
    // Read the database
    Configuration Database;
@@ -593,14 +593,14 @@ bool DoAdd(CommandLine &)
    if (PreFetch == false && _config->FindB("APT::CDROM::NoMount",false) == false)
    {
       Mounted = true;
-      cout << _("Unmounting CD-ROM") << endl;
+      cout << _("Unmounting Media") << endl;
       UnmountCdrom(CDROM);
 
       // Mount the new CDROM
-      Prompt(_("Please insert a Disc in the drive and press enter"));
-      cout << _("Mounting CD-ROM") << endl;
+      Prompt(_("Please insert a Media and press enter"));
+      cout << _("Mounting Media") << endl;
       if (MountCdrom(CDROM) == false)
-	 return _error->Error(_("Failed to mount the cdrom."));
+	 return _error->Error(_("Failed to mount the Media."));
    }
    
    // Hash the CD to get an ID
@@ -624,7 +624,7 @@ bool DoAdd(CommandLine &)
 
    cout << '[' << ID << ']' << endl;
 
-   cout << _("Scanning Disc for index files..  ") << flush;
+   cout << _("Scanning Media for index files..  ") << flush;
    // Get the CD structure
    vector<string> List;
    vector<string> sList;
@@ -700,7 +700,7 @@ bool DoAdd(CommandLine &)
 	  Name.empty() == true)
       {
 	 // CNC:2003-11-25
-	 cout << _("Please provide a name for this Disc, such as 'Distribution Disk 1'");
+	 cout << _("Please provide a name for this Media, such as 'Distribution Disk 1'");
 	 while (1)
 	 {
 	    Name = PromptLine("");
@@ -723,7 +723,7 @@ bool DoAdd(CommandLine &)
 	 *J = '_';
    
    Database.Set("CD::" + ID,Name);
-   cout << _("This Disc is called:") << endl << " '" << Name << "'" << endl;
+   cout << _("This Media is called:") << endl << " '" << Name << "'" << endl;
    
    // Copy the package files to the state directory
 // CNC:2002-07-11
@@ -756,7 +756,7 @@ bool DoAdd(CommandLine &)
    }
 
    // Print the sourcelist entries
-   cout << _("Source List entries for this Disc are:") << endl;
+   cout << _("Source List entries for this Media are:") << endl;
    for (vector<string>::iterator I = List.begin(); I != List.end(); I++)
    {
       string::size_type Space = (*I).find(' ');
@@ -789,7 +789,7 @@ bool DoAdd(CommandLine &)
 #endif
    }
 
-   cout << _("Repeat this process for the rest of the CDs in your set.") << endl;
+   cout << _("Repeat this process for the rest of the Media in your set.") << endl;
 
    // Unmount and finish
    // CNC:2002-10-29
@@ -809,8 +809,8 @@ bool DoIdent(CommandLine &)
    if (CDROM[0] == '.')
       CDROM= SafeGetCWD() + '/' + CDROM;
    
-   cout << _("Using CD-ROM mount point ") << CDROM << endl;
-   cout << _("Mounting CD-ROM") << endl;
+   cout << _("Using Media mount point ") << CDROM << endl;
+   cout << _("Mounting Media") << endl;
    if (MountCdrom(CDROM) == false)
       return _error->Error(_("Failed to mount the cdrom."));
    
@@ -852,18 +852,18 @@ int ShowHelp()
    cout << 
     _("Usage: apt-cdrom [options] command\n"
       "\n"
-      "apt-cdrom is a tool to add CDROM's to APT's source list. The\n"
-      "CDROM mount point and device information is taken from apt.conf\n"
+      "apt-cdrom is a tool to add Media to APT's source list. The\n"
+      "mount point and device information is taken from apt.conf\n"
       "and /etc/fstab.\n"
       "\n"
       "Commands:\n"
-      "   add - Add a CDROM\n"
-      "   ident - Report the identity of a CDROM\n"
+      "   add - Add a Media\n"
+      "   ident - Report the identity of a Media\n"
       "\n"
       "Options:\n"
       "  -h   This help text\n"
-      "  -d   CD-ROM mount point\n"
-      "  -r   Rename a recognized CD-ROM\n"
+      "  -d   Media mount point\n"
+      "  -r   Rename a recognized Media\n"
       "  -m   No mounting\n"
       "  -f   Fast mode, don't check package files\n"
       "  -a   Thorough scan mode\n"
@@ -902,8 +902,8 @@ int main(int argc,const char *argv[])
    // Parse the command line and initialize the package library
    CommandLine CmdL(Args,_config);
    if (pkgInitConfig(*_config) == false ||
-       CmdL.Parse(argc,argv) == false ||
-       pkgInitSystem(*_config,_system) == false)
+       pkgInitSystem(*_config,_system) == false ||
+       CmdL.Parse(argc,argv) == false)
    {
       _error->DumpErrors();
       return 100;
diff --git a/cmdline/apt-config.cc b/cmdline/apt-config.cc
index 084314b..723e33c 100644
--- a/cmdline/apt-config.cc
+++ b/cmdline/apt-config.cc
@@ -16,12 +16,13 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include <apt-pkg/cmndline.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/init.h>
 #include <apt-pkg/strutl.h>
 
-#include <config.h>
 #include <apti18n.h>
 
 // CNC:2003-02-14 - apti18n.h includes libintl.h which includes locale.h,
@@ -110,8 +111,8 @@ int main(int argc,const char *argv[])
    // Parse the command line and initialize the package library
    CommandLine CmdL(Args,_config);
    if (pkgInitConfig(*_config) == false ||
-       CmdL.Parse(argc,argv) == false ||
-       pkgInitSystem(*_config,_system) == false)
+       pkgInitSystem(*_config,_system) == false ||
+       CmdL.Parse(argc,argv) == false)
    {
       _error->DumpErrors();
       return 100;
diff --git a/cmdline/apt-get.cc b/cmdline/apt-get.cc
index c0749e6..3e2f505 100644
--- a/cmdline/apt-get.cc
+++ b/cmdline/apt-get.cc
@@ -25,6 +25,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include <apt-pkg/error.h>
 #include <apt-pkg/cmndline.h>
 #include <apt-pkg/init.h>
@@ -40,7 +42,6 @@
 #include <apt-pkg/sptr.h>
 #include <apt-pkg/versionmatch.h>
     
-#include <config.h>
 #include <apti18n.h>
 
 #include "acqprogress.h"
@@ -71,6 +72,7 @@ using namespace std;
 ostream c0out(0);
 ostream c1out(0);
 ostream c2out(0);
+ostream c3out(0); // script output stream
 ofstream devnull("/dev/null");
 unsigned int ScreenWidth = 80;
 
@@ -418,6 +420,7 @@ void ShowNew(ostream &out,CacheFile &Cache)
       }
    }
    
+   if (!List.empty()) c3out<<"apt-get:install-list:"<<List<<endl;
    ShowList(out,_("The following NEW packages will be installed:"),List,VersionsList);
 }
 									/*}}}*/
@@ -469,8 +472,11 @@ void ShowDel(ostream &out,CacheFile &Cache)
       }
    }
    
+   
    // CNC:2002-07-25
+   if (!RepList.empty()) c3out<<"apt-get:replace-list:"<<RepList<<endl;;
    ShowList(out,_("The following packages will be REPLACED:"),RepList,VersionsList);
+   if (!List.empty()) c3out<<"apt-get:remove-list:"<<List<<endl;
    ShowList(out,_("The following packages will be REMOVED:"),List,VersionsList);
 }
 									/*}}}*/
@@ -493,6 +499,7 @@ void ShowKept(ostream &out,CacheFile &Cache)
       List += string(I.Name()) + " ";
       VersionsList += string(Cache[I].CurVersion) + " => " + Cache[I].CandVersion + "\n";
    }
+   if (!List.empty()) c3out<<"apt-get:keep-list:"<<List<<endl;
    ShowList(out,_("The following packages have been kept back"),List,VersionsList);
 }
 									/*}}}*/
@@ -514,6 +521,7 @@ void ShowUpgraded(ostream &out,CacheFile &Cache)
       List += string(I.Name()) + " ";
       VersionsList += string(Cache[I].CurVersion) + " => " + Cache[I].CandVersion + "\n";
    }
+   if (!List.empty()) c3out<<"apt-get:upgrade-list:"<<List<<endl;
    ShowList(out,_("The following packages will be upgraded"),List,VersionsList);
 }
 									/*}}}*/
@@ -535,6 +543,7 @@ bool ShowDowngraded(ostream &out,CacheFile &Cache)
       List += string(I.Name()) + " ";
       VersionsList += string(Cache[I].CurVersion) + " => " + Cache[I].CandVersion + "\n";
    }
+   if (!List.empty()) c3out<<"apt-get:downgrade-list:"<<List<<endl;
    return ShowList(out,_("The following packages will be DOWNGRADED"),List,VersionsList);
 }
 									/*}}}*/
@@ -555,6 +564,7 @@ bool ShowHold(ostream &out,CacheFile &Cache)
       }
    }
 
+   if (!List.empty()) c3out<<"apt-get:hold-list:"<<List<<endl;
    return ShowList(out,_("The following held packages will be changed:"),List,VersionsList);
 }
 									/*}}}*/
@@ -652,6 +662,7 @@ bool ShowEssential(ostream &out,CacheFile &Cache)
    }
    
    delete [] Added;
+   if (!List.empty()) c3out<<"apt-get:essential-list:"<<List<<endl;
    return ShowList(out,_("WARNING: The following essential packages will be removed\n"
 			 "This should NOT be done unless you know exactly what you are doing!"),List,VersionsList);
 }
@@ -705,6 +716,12 @@ void Stats(ostream &out,pkgDepCache &Dep)
       else if ((Dep[I].iFlags & pkgDepCache::ReInstall) == pkgDepCache::ReInstall)
 	 ReInstall++;
    }   
+   c3out<<"apt-get:status:upgrade:"<<Upgrade<<endl;
+   c3out<<"apt-get:status:downgrade:"<<Downgrade<<endl;
+   c3out<<"apt-get:status:install:"<<Install<<endl;
+   c3out<<"apt-get:status:re-install:"<<ReInstall<<endl;
+   c3out<<"apt-get:status:replace:"<<Replace<<endl;
+   c3out<<"apt-get:status:remove:"<<Remove<<endl;
 
    ioprintf(out,_("%lu upgraded, %lu newly installed, "),
 	    Upgrade,Install);
@@ -814,7 +831,7 @@ bool CacheFile::CheckDeps(bool AllowBroken)
       if (pkgFixBroken(*DCache) == false || DCache->BrokenCount() != 0)
       {
 	 c1out << _(" failed.") << endl;
-	 ShowBroken(c1out,*this,true);
+	 ShowBroken(cerr,*this,true);
 
 	 return _error->Error(_("Unable to correct dependencies"));
       }
@@ -826,7 +843,7 @@ bool CacheFile::CheckDeps(bool AllowBroken)
    else
    {
       c1out << _("You might want to run `apt-get --fix-broken install' to correct these.") << endl;
-      ShowBroken(c1out,*this,true);
+      ShowBroken(cerr,*this,true);
 
       return _error->Error(_("Unmet dependencies. Try using --fix-broken."));
    }
@@ -876,7 +893,7 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
    // Sanity check
    if (Cache->BrokenCount() != 0)
    {
-      ShowBroken(c1out,Cache,false);
+      ShowBroken(cerr,Cache,false);
       return _error->Error("Internal Error, InstallPackages was called with broken packages!");
    }
 
@@ -955,6 +972,7 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
    else
       ioprintf(c1out,_("After unpacking %sB disk space will be freed.\n"),
 	       SizeToStr(-1*Cache->UsrSize()).c_str());
+   c3out<<"apt-get:status:disk-size:"<<SizeToStr(Cache->UsrSize())<<endl;
 
    if (_error->PendingError() == true)
       return false;
@@ -1011,6 +1029,7 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
 	 if (_config->FindI("quiet",0) < 2 &&
 	     _config->FindB("APT::Get::Assume-Yes",false) == false)
 	 {
+	    c3out << "apt-get:wait-yes-no:" << endl;
 	    c2out << _("Do you want to continue? [Y/n] ") << flush;
 	 
 	    if (YnPrompt() == false)
@@ -1025,6 +1044,14 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
    // Just print out the uris an exit if the --print-uris flag was used
    if (_config->FindB("APT::Get::Print-URIs") == true)
    {
+      if (_config->FindB("APT::Get::PrintLocalFile"))
+      {
+         struct stat stb;
+         for (pkgAcquire::ItemIterator I = Fetcher.ItemsBegin(); I < Fetcher.ItemsEnd(); ++I)
+            if (((*I)->Local) && !stat((*I)->DestFile.c_str(), &stb))
+               cout << (*I)->DestFile << endl;
+         return true;
+      }
       pkgAcquire::UriIterator I = Fetcher.UriBegin();
       for (; I != Fetcher.UriEnd(); I++)
 	 cout << '\'' << I->URI << "' " << flNotDir(I->Owner->DestFile) << ' ' << 
@@ -1216,14 +1243,28 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
    if (Pkg->VersionList == 0 && Pkg->ProvidesList != 0)
    {
       vector<pkgCache::Package *> GoodSolutions;
+      unsigned long Size = 0;
       for (pkgCache::PrvIterator Prv = Pkg.ProvidesList();
 	   Prv.end() == false; Prv++)
+	 Size++;
+      SPtrArray<pkgCache::Package *> PList = new pkgCache::Package *[Size];
+      pkgCache::Package **PEnd = PList;
+      for (pkgCache::PrvIterator Prv = Pkg.ProvidesList(); Prv.end() == false; Prv++)
+         *PEnd++ = Prv.OwnerPkg();
+      Fix.MakeScores();
+      qsort(PList,PEnd - PList,sizeof(*PList),&(Fix.ScoreSort));
+
+      for (unsigned int p=0; p<Size; ++p)
       {
-	 pkgCache::PkgIterator PrvPkg = Prv.OwnerPkg();
+         bool instVirtual = _config->FindB("APT::Install::Virtual", false);
+         pkgCache::PkgIterator PrvPkg = pkgCache::PkgIterator(*Pkg.Cache(), PList[p]);
+         pkgCache::PrvIterator Prv = Pkg.ProvidesList();
+         for (; Prv.end() == false && Prv.OwnerPkg() != PrvPkg; Prv++)
+           ;
 	 // Check if it's a different version of a package already
 	 // considered as a good solution.
 	 bool AlreadySeen = false;
-	 for (int i = 0; i != GoodSolutions.size(); i++)
+	 for (unsigned int i = 0; i != GoodSolutions.size(); i++)
 	 {
 	    pkgCache::PkgIterator GoodPkg(Cache, GoodSolutions[i]);
 	    if (PrvPkg == GoodPkg)
@@ -1241,6 +1282,8 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
 	    // the user might try to install something he already has
 	    // without being aware.
 	    GoodSolutions.push_back(PrvPkg);
+	    if (instVirtual)
+		break;
 	    continue;
 	 }
 	 pkgCache::VerIterator PrvPkgCandVer =
@@ -1251,21 +1294,33 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
 	    continue;
 	 }
 	 // Is the provides pointing to the candidate version?
-	 if (PrvPkgCandVer == Prv.OwnerVer())
+	 bool good = false;
+	 for (; PrvPkgCandVer.end() == false; ++PrvPkgCandVer)
 	 {
-	    // Yes, it is. This is a good solution.
-	    GoodSolutions.push_back(PrvPkg);
-	    continue;
+	    if (PrvPkgCandVer == Prv.OwnerVer())
+	    {
+	       // Yes, it is. This is a good solution.
+	       good = true;
+	       GoodSolutions.push_back(PrvPkg);
+	    }
 	 }
+	 if (good && instVirtual)
+	    break;
       }
       vector<string> GoodSolutionNames;
-      for (int i = 0; i != GoodSolutions.size(); i++)
+      unsigned int GoodSolutionsInstalled = 0, GoodSolutionInstallNumber = 0;
+      for (unsigned int i = 0; i < GoodSolutions.size(); i++)
       {
 	 pkgCache::PkgIterator GoodPkg(Cache, GoodSolutions[i]);
 	 GoodSolutionNames.push_back(GoodPkg.Name());
+	 if (GoodPkg.CurrentVer().end() == false)
+	 {
+	    GoodSolutionsInstalled++;
+	    GoodSolutionInstallNumber = i;
+	 }
       }
 #ifdef WITH_LUA
-      if (GoodSolutions.size() > 1)
+      if (GoodSolutions.size() > 1 && !(Remove && GoodSolutionsInstalled == 1))
       {
 	 vector<string> VS;
 	 _lua->SetDepCache(&Cache);
@@ -1290,7 +1345,8 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
 	 _lua->ResetCaches();
       }
 #endif
-      if (GoodSolutions.size() == 1)
+      if (GoodSolutions.size() == 1 ||
+          ((GoodSolutions.size() > 1) && Remove && GoodSolutionsInstalled == 1))
       {
 	 pkgCache::PkgIterator GoodPkg(Cache, GoodSolutions[0]);
 	 ioprintf(c1out,_("Selecting %s for '%s'\n"),
@@ -1305,20 +1361,23 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
       }
       else
       {
-	 ioprintf(c1out,_("Package %s is a virtual package provided by:\n"),
+	 ioprintf(cerr,_("Package %s is a virtual package provided by:\n"),
 		  Pkg.Name());
-	 for (int i = 0; i != GoodSolutions.size(); i++)
+	 for (unsigned int i = 0; i != GoodSolutions.size(); i++)
 	 {
 	    pkgCache::PkgIterator GoodPkg(Cache, GoodSolutions[i]);
 	    if (GoodPkg.CurrentVer().end() == false)
-	       c1out << "  " << GoodSolutionNames[i]
+	       cerr  << "  " << GoodSolutionNames[i]
 		     << " "  << Cache[GoodPkg].CandVersion
 		     << _(" [Installed]") << endl;
 	    else
-	       c1out << "  " << GoodSolutionNames[i]
+	       cerr  << "  " << GoodSolutionNames[i]
 		     << " "  << Cache[GoodPkg].CandVersion << endl;
 	 }
-	 c1out << _("You should explicitly select one to install.") << endl;
+	 if (Remove)
+	   cerr << _("You should explicitly select one to remove.") << endl;
+	 else
+	   cerr << _("You should explicitly select one to install.") << endl;
 	 _error->Error(_("Package %s is a virtual package with multiple "
 			 "good providers.\n"), Pkg.Name());
 	 return false;
@@ -1406,6 +1465,7 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
 	    List += string(Dep.ParentPkg().Name()) + " ";
         //VersionsList += string(Dep.ParentPkg().CurVersion) + "\n"; ???
 	 }	    
+	 if (!List.empty()) c3out<<"apt-get:however-replace-list:"<<List<<endl;
 	 ShowList(c1out,_("However the following packages replace it:"),List,VersionsList);
       }
       
@@ -1428,12 +1488,15 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
    {
       if (_config->FindB("APT::Get::ReInstall",false) == true)
       {
-	 if (Pkg->CurrentVer == 0 || Pkg.CurrentVer().Downloadable() == false)
-	    ioprintf(c1out,_("Reinstallation of %s is not possible, it cannot be downloaded.\n"),
+	 if (Pkg->CurrentVer == 0)
+	    ioprintf(c1out,_("Reinstallation of %s is not possible.\n"),
 		     Pkg.Name());
+	 else if (Pkg.CurrentVer().Downloadable() == false)
+	    ioprintf(c1out,_("Reinstallation of %s %s is not possible, it cannot be downloaded.\n"),
+		     Pkg.Name(), Pkg.CurrentVer().VerStr());
 	 else
 	    Cache.SetReInstall(Pkg,true);
-      }      
+      }
       else
       {
 	 if (AllowFail == true)
@@ -1469,17 +1532,64 @@ static const char *op2str(int op)
    }
 }
 
+// best versions go first
+class bestVersionOrder
+{
+   private:
+      pkgDepCache &Cache_;
+      pkgProblemResolver &Fix_;
+   public:
+      bestVersionOrder(pkgDepCache &Cache, pkgProblemResolver &Fix)
+	 : Cache_(Cache), Fix_(Fix) { }
+      bool operator() (const pkgCache::VerIterator &a, const pkgCache::VerIterator &b)
+      {
+	 // CmpVersion sorts ascending
+	 int cmp = Cache_.VS().CmpVersion(a.VerStr(), b.VerStr());
+	 if (cmp == 0)
+	 {
+	    const pkgCache::Package *A = &(*a.ParentPkg());
+	    const pkgCache::Package *B = &(*b.ParentPkg());
+	    // ScoreSort sorts descending
+	    cmp = Fix_.ScoreSort(&B, &A);
+	 }
+	 //fprintf(stderr, "%s %s <=> %s %s = %d\n",
+	 //      a.ParentPkg().Name(), a.VerStr(),
+	 //      b.ParentPkg().Name(), b.VerStr(),
+	 //      cmp);
+	 return cmp > 0;
+      }
+};
+
+static void __attribute__((unused))
+printVerList(const char *msg, const std::list<pkgCache::VerIterator> &list)
+{
+   std::list<pkgCache::VerIterator>::const_iterator I = list.begin();
+   for ( ; I != list.end(); ++I)
+   {
+      if (I == list.begin())
+	 fprintf(stderr, "%s: ", msg);
+      else
+	 fprintf(stderr, ", ");
+      
+      const pkgCache::VerIterator &Ver = *I;
+      fprintf(stderr, "%s#%s", Ver.ParentPkg().Name(), Ver.VerStr());
+   }
+   fprintf(stderr, "\n");
+}
+
 // CNC:2003-11-11
 bool TryToChangeVer(pkgCache::PkgIterator &Pkg,pkgDepCache &Cache,
+		    pkgProblemResolver &Fix,
  		    int VerOp,const char *VerTag,bool IsRel)
 {
    // CNC:2003-11-05
    pkgVersionMatch Match(VerTag,(IsRel == true?pkgVersionMatch::Release : 
  				 pkgVersionMatch::Version),VerOp);
    
-   pkgCache::VerIterator Ver = Match.Find(Pkg);
-			 
-   if (Ver.end() == true)
+   std::list<pkgCache::VerIterator> found = Match.FindAll(Pkg);
+   //printVerList("found", found);
+
+   if (found.size() == 0)
    {
       // CNC:2003-11-05
       if (IsRel == true)
@@ -1488,16 +1598,67 @@ bool TryToChangeVer(pkgCache::PkgIterator &Pkg,pkgDepCache &Cache,
       return _error->Error(_("Version %s'%s' for '%s' was not found"),
 			   op2str(VerOp),VerTag,Pkg.Name());
    }
+
+   if (found.size() > 1)
+   {
+      Fix.MakeScores();
+      bestVersionOrder order(Cache,Fix);
+      found.sort(order);
+      found.unique();
+      //printVerList("sorted", found);
+   }
+
+   pkgCache::VerIterator Ver = found.front();
+   int already = 0;
+
+   std::list<pkgCache::VerIterator>::const_iterator I = found.begin();
+   for ( ; I != found.end(); ++I)
+   {
+      const pkgCache::VerIterator &V = *I;
+      if (V.ParentPkg().CurrentVer() == V)
+      {
+	 Ver = V;
+	 already = 2;
+	 break;
+      }
+      if (Cache[V.ParentPkg()].InstallVer == V)
+      {
+	 Ver = V;
+	 already = 1;
+	 break;
+      }
+   }
    
-   if (strcmp(VerTag,Ver.VerStr()) != 0)
+   if (strcmp(VerTag,Ver.VerStr()) != 0 || found.size() > 1)
    {
       // CNC:2003-11-11
+      const char *fmt;
       if (IsRel == true)
-	 ioprintf(c1out,_("Selected version %s (%s) for %s\n"),
-		  Ver.VerStr(),Ver.RelStr().c_str(),Pkg.Name());
+      {
+	 if (already > 1)
+	    fmt = _("Version %s#%s (%s) for %s%s%s is already installed\n");
+	 else if (already)
+	    fmt = _("Version %s#%s (%s) for %s%s%s is already selected for install\n");
+	 else
+	    fmt = _("Selected version %s#%s (%s) for %s%s%s\n");
+
+	 ioprintf(c1out,fmt,
+		  Ver.ParentPkg().Name(),Ver.VerStr(),Ver.RelStr().c_str(),
+		  Pkg.Name(),op2str(VerOp),VerTag);
+      }
       else
-	 ioprintf(c1out,_("Selected version %s for %s\n"),
-		  Ver.VerStr(),Pkg.Name());
+      {
+	 if (already > 1)
+	    fmt = _("Version %s#%s for %s%s%s is already installed\n");
+	 else if (already)
+	    fmt = _("Version %s#%s for %s%s%s is already selected for install\n");
+	 else
+	    fmt = _("Selected version %s#%s for %s%s%s\n");
+
+	 ioprintf(c1out,fmt,
+		  Ver.ParentPkg().Name(),Ver.VerStr(),
+		  Pkg.Name(),op2str(VerOp),VerTag);
+      }
    }
    
    Cache.SetCandidateVersion(Ver);
@@ -1703,6 +1864,14 @@ bool DoUpdate(CommandLine &CmdL)
    // Just print out the uris an exit if the --print-uris flag was used
    if (_config->FindB("APT::Get::Print-URIs") == true)
    {
+      if (_config->FindB("APT::Get::PrintLocalFile"))
+      {
+         struct stat stb;
+         for (pkgAcquire::ItemIterator I = Fetcher.ItemsBegin(); I < Fetcher.ItemsEnd(); ++I)
+            if (((*I)->Local) && !stat((*I)->DestFile.c_str(), &stb))
+               cout << (*I)->DestFile << endl;
+         return true;
+      }
       pkgAcquire::UriIterator I = Fetcher.UriBegin();
       for (; I != Fetcher.UriEnd(); I++)
 	 cout << '\'' << I->URI << "' " << flNotDir(I->Owner->DestFile) << ' ' << 
@@ -1752,7 +1921,7 @@ bool DoUpdate(CommandLine &CmdL)
 #endif
 
    // CNC:2004-04-19
-   if (Failed == false && _config->FindB("APT::Get::Archive-Cleanup",true) == true)
+   if (Failed == false && _config->FindB("APT::Get::Archive-Cleanup",false) == true)
    {
       UpdateLogCleaner Cleaner;
       Cleaner.Go(_config->FindDir("Dir::Cache::archives"), *Cache);
@@ -1779,7 +1948,7 @@ bool DoUpgrade(CommandLine &CmdL)
    // Do the upgrade
    if (pkgAllUpgrade(Cache) == false)
    {
-      ShowBroken(c1out,Cache,false);
+      ShowBroken(cerr,Cache,false);
       return _error->Error(_("Internal Error, AllUpgrade broke stuff"));
    }
 
@@ -1897,7 +2066,10 @@ bool DoInstall(CommandLine &CmdL)
 		  return _error->Error(_("Couldn't parse name '%s'"),S);
 	    }
 	    *sep = '\0';
-	    VerTag = p;
+	    /* S may be overwritten later, for example, if it contains
+	     * a file name that will be resolved to a package.
+	     * So we point VerTag to the same offset in OrigS. */
+	    VerTag = (p - S) + OrigS;
 	 }
 	 
 	 // CNC:2003-11-21 - Try to handle unknown file items.
@@ -1989,7 +2161,7 @@ bool DoInstall(CommandLine &CmdL)
 	    if (Hit == true)
 	       continue;
 #endif
-	    return _error->Error(_("Couldn't find package %s"),S);
+	    return _error->Error(_("Couldn't find package %s"), OrigS);
 	 }
 
 	 // Regexs must always be confirmed
@@ -2015,11 +2187,11 @@ bool DoInstall(CommandLine &CmdL)
 	    
 	    // CNC:2003-11-23
 	    ioprintf(c1out,_("Selecting %s for '%s'\n"),
-		     Pkg.Name(),S);
+		     Pkg.Name(), OrigS);
 	    
 	    if (VerTag != 0)
 	       // CNC:2003-11-05
-	       if (TryToChangeVer(Pkg,Cache,VerOp,VerTag,VerIsRel) == false)
+	       if (TryToChangeVer(Pkg,Cache,Fix,VerOp,VerTag,VerIsRel) == false)
 		  return false;
 	    
 	    Hit |= TryToInstall(Pkg,Cache,Fix,Remove,BrokenFix,
@@ -2028,13 +2200,13 @@ bool DoInstall(CommandLine &CmdL)
 	 regfree(&Pattern);
 	 
 	 if (Hit == false)
-	    return _error->Error(_("Couldn't find package %s"),S);
+	    return _error->Error(_("Couldn't find package %s"), OrigS);
       }
       else
       {
 	 if (VerTag != 0)
 	    // CNC:2003-11-05
-	    if (TryToChangeVer(Pkg,Cache,VerOp,VerTag,VerIsRel) == false)
+	    if (TryToChangeVer(Pkg,Cache,Fix,VerOp,VerTag,VerIsRel) == false)
 	       return false;
 	 if (TryToInstall(Pkg,Cache,Fix,Remove,BrokenFix,ExpectedInst) == false)
 	    return false;
@@ -2059,7 +2231,7 @@ bool DoInstall(CommandLine &CmdL)
    if (BrokenFix == true && Cache->BrokenCount() != 0)
    {
       c1out << _("You might want to run `apt-get --fix-broken install' to correct these:") << endl;
-      ShowBroken(c1out,Cache,false);
+      ShowBroken(cerr,Cache,false);
 
       return _error->Error(_("Unmet dependencies. Try 'apt-get --fix-broken install' with no packages (or specify a solution)."));
    }
@@ -2098,7 +2270,7 @@ bool DoInstall(CommandLine &CmdL)
 
       c1out << _("The following information may help to resolve the situation:") << endl;
       c1out << endl;
-      ShowBroken(c1out,Cache,false);
+      ShowBroken(cerr,Cache,false);
       return _error->Error(_("Broken packages"));
    }   
    
@@ -2126,6 +2298,7 @@ bool DoInstall(CommandLine &CmdL)
      }
       }
       
+      if (!List.empty()) c3out<<"apt-get:extra-list:"<<List<<endl;
       ShowList(c1out,_("The following extra packages will be installed:"),List,VersionsList);
    }
 
@@ -2206,7 +2379,9 @@ bool DoInstall(CommandLine &CmdL)
 	       }
 	   }
       }
+      if (!SuggestsList.empty()) c3out<<"apt-get:suggest-list:"<<SuggestsList<<endl;
       ShowList(c1out,_("Suggested packages:"),SuggestsList,SuggestsVersions);
+      if (!RecommendsList.empty()) c3out<<"apt-get:recommended-list:"<<RecommendsList<<endl;
       ShowList(c1out,_("Recommended packages:"),RecommendsList,RecommendsVersions);
 
    }
@@ -2235,7 +2410,7 @@ bool DoDistUpgrade(CommandLine &CmdL)
    if (pkgDistUpgrade(*Cache) == false)
    {
       c0out << _("Failed") << endl;
-      ShowBroken(c1out,Cache,false);
+      ShowBroken(cerr,Cache,false);
       return false;
    }
 
@@ -2314,7 +2489,7 @@ bool DoDSelectUpgrade(CommandLine &CmdL)
    
       if (Fix.Resolve() == false)
       {
-	 ShowBroken(c1out,Cache,false);
+	 ShowBroken(cerr,Cache,false);
 	 return _error->Error("Internal Error, problem resolver broke stuff");
       }
    }
@@ -2322,7 +2497,7 @@ bool DoDSelectUpgrade(CommandLine &CmdL)
    // Now upgrade everything
    if (pkgAllUpgrade(Cache) == false)
    {
-      ShowBroken(c1out,Cache,false);
+      ShowBroken(cerr,Cache,false);
       return _error->Error("Internal Error, problem resolver broke stuff");
    }
 
@@ -2514,6 +2689,9 @@ bool DoSource(CommandLine &CmdL)
 	     I->Type != "tar")
 	    continue;
 	 
+	if (_config->FindB("Debug::pkgAcquire::Auth",false) == true)
+	    cerr << "I->Path = " << I->Path << ", I->MD5Hash = " << I->MD5Hash << endl;
+
 	 new pkgAcqFile(&Fetcher,Last->Index().ArchiveURI(I->Path),
 			I->MD5Hash,I->Size,
 			Last->Index().SourceInfo(*Last,*I),Src);
@@ -2554,6 +2732,14 @@ bool DoSource(CommandLine &CmdL)
    // Just print out the uris an exit if the --print-uris flag was used
    if (_config->FindB("APT::Get::Print-URIs") == true)
    {
+      if (_config->FindB("APT::Get::PrintLocalFile"))
+      {
+         struct stat stb;
+         for (pkgAcquire::ItemIterator I = Fetcher.ItemsBegin(); I < Fetcher.ItemsEnd(); ++I)
+            if (((*I)->Local) && !stat((*I)->DestFile.c_str(), &stb))
+               cout << (*I)->DestFile << endl;
+         return true;
+      }
       pkgAcquire::UriIterator I = Fetcher.UriBegin();
       for (; I != Fetcher.UriEnd(); I++)
 	 cout << '\'' << I->URI << "' " << flNotDir(I->Owner->DestFile) << ' ' << 
@@ -2948,7 +3134,7 @@ bool DoBuildDep(CommandLine &CmdL)
       if (Cache->BrokenCount() != 0)
       {
          // CNC:2004-07-05
-         ShowBroken(c1out, Cache, false);
+         ShowBroken(cerr, Cache, false);
 	 return _error->Error(_("Some broken packages were found while trying to process build-dependencies for %s.\n"
 				"You might want to run `apt-get --fix-broken install' to correct these."),*I);
       }
@@ -2965,24 +3151,6 @@ bool DoBuildDep(CommandLine &CmdL)
 }
 									/*}}}*/
 
-// DoMoo - Never Ask, Never Tell					/*{{{*/
-// ---------------------------------------------------------------------
-/* */
-bool DoMoo(CommandLine &CmdL)
-{
-   cout << 
-      "         (__) \n"
-      "         (oo) \n"
-      "   /------\\/ \n"
-      "  / |    ||   \n" 
-      " *  /\\---/\\ \n"
-      "    ~~   ~~   \n"
-      "....\"Have you mooed today?\"...\n";
-			    
-   return true;
-}
-									/*}}}*/
-
 // CNC:2003-03-18
 // DoScript - Scripting stuff.						/*{{{*/
 // ---------------------------------------------------------------------
@@ -3151,6 +3319,7 @@ int main(int argc,const char *argv[])
       {'v',"version","version",0},
       {'V',"verbose-versions","APT::Get::Show-Versions",0},
       {'q',"quiet","quiet",CommandLine::IntLevel},
+      { 0, "simple-output","simple-output",0},
       {'q',"silent","quiet",CommandLine::IntLevel},
       {'d',"download-only","APT::Get::Download-Only",0},
       {'b',"compile","APT::Get::Compile",0},
@@ -3186,6 +3355,7 @@ int main(int argc,const char *argv[])
       {0,"check-only","APT::Get::Check-Only",0}, // CNC:2003-03-06
       {'c',"config-file",0,CommandLine::ConfigFile},
       {'o',"option",0,CommandLine::ArbItem},
+      {0,"manifest","manifest",CommandLine::HasArg},
       {0,0,0,0}};
    CommandLine::Dispatch Cmds[] = {{"update",&DoUpdate},
                                    {"upgrade",&DoUpgrade},
@@ -3200,7 +3370,6 @@ int main(int argc,const char *argv[])
                                    {"autoclean",&DoAutoClean},
                                    {"check",&DoCheck},
 				   {"source",&DoSource},
-				   {"moo",&DoMoo},
 				   {"help",&ShowHelp},
 // CNC:2003-03-19
 #ifdef WITH_LUA
@@ -3215,8 +3384,8 @@ int main(int argc,const char *argv[])
    // Parse the command line and initialize the package library
    CommandLine CmdL(Args,_config);
    if (pkgInitConfig(*_config) == false ||
-       CmdL.Parse(argc,argv) == false ||
-       pkgInitSystem(*_config,_system) == false)
+       pkgInitSystem(*_config,_system) == false ||
+       CmdL.Parse(argc,argv) == false)
    {
       if (_config->FindB("version") == true)
 	 ShowHelp(CmdL);
@@ -3225,6 +3394,27 @@ int main(int argc,const char *argv[])
       return 100;
    }
 
+   //append manifest content to FileList
+   if (!_config->Find("manifest").empty())
+   {
+     std::ifstream is(_config->Find("manifest").c_str());
+     vector<char*> new_filelist;
+     std::string line;
+
+     for (const char **I = CmdL.FileList; *I != 0; I++)
+       new_filelist.push_back(strdup(*I));
+     while (std::getline(is,line))
+        new_filelist.push_back(strdup(line.c_str()));
+
+     CmdL.FreeFileList();
+     
+     size_t len = new_filelist.size();
+     CmdL.FileList = new const char *[len + 1];
+     for(int i=0;i<len;++i)
+        CmdL.FileList[i]=new_filelist[i];
+     CmdL.FileList[len] = 0;
+   }
+
    // See if the help should be shown
    if (_config->FindB("help") == true ||
        _config->FindB("version") == true ||
@@ -3244,7 +3434,9 @@ int main(int argc,const char *argv[])
 	 if (strstr(*I, "://") != NULL)
 	 {
 	    URLLst.push_back(*I);
-	    *I = strrchr(*I, '/')+1;
+	    const char *N = strdup(strrchr(*I, '/')+1);
+	    free((void *)*I);
+	    *I = N;
 	 }
       }
 
@@ -3263,9 +3455,21 @@ int main(int argc,const char *argv[])
       _config->Set("quiet","1");
 
    // Setup the output streams
-   c0out.rdbuf(cout.rdbuf());
-   c1out.rdbuf(cout.rdbuf());
-   c2out.rdbuf(cout.rdbuf());
+   if (_config->FindB("simple-output"))
+   {
+   	c0out.rdbuf(devnull.rdbuf());
+ 	c1out.rdbuf(devnull.rdbuf());
+ 	c2out.rdbuf(devnull.rdbuf());
+	c3out.rdbuf(cout.rdbuf());
+   }
+   else
+   {
+        c0out.rdbuf(cout.rdbuf());
+        c1out.rdbuf(cout.rdbuf());
+        c2out.rdbuf(cout.rdbuf());
+        c3out.rdbuf(devnull.rdbuf());
+   }
+   
    if (_config->FindI("quiet",0) > 0)
       c0out.rdbuf(devnull.rdbuf());
    if (_config->FindI("quiet",0) > 1)
diff --git a/cmdline/apt-pipe.c b/cmdline/apt-pipe.c
new file mode 100644
index 0000000..7bf1fc6
--- /dev/null
+++ b/cmdline/apt-pipe.c
@@ -0,0 +1,389 @@
+/* ----------------------------------------------------------------------------
+   $Id: apt-pipe.c,v 1.3 2005/03/20 20:56:03 me Exp $
+ */
+
+#ifndef APT_PIPE_PATH
+#define APT_PIPE_PATH "/var/lib/apt/pipe"
+#endif
+
+#include <config.h>
+
+#include <argz.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#include <setproctitle.h>
+
+/* ----------------------------------------------------------------------------
+*/
+
+extern int aptpipe_init(void);
+extern int aptpipe_main(int, const char **);
+extern int aptpipe_fini(void);
+
+/* ----------------------------------------------------------------------------
+ */
+
+static volatile sig_atomic_t signalled = 0;
+
+/* ----------------------------------------------------------------------------
+  server
+*/
+static void sighandler(int sig)
+{
+	++signalled;
+}
+
+static void set_sighandler(int flags)
+{
+ 	struct sigaction sa;
+
+	sa.sa_handler = sighandler;
+	sigemptyset(&sa.sa_mask);
+	sigaddset(&sa.sa_mask, SIGINT);
+	sigaddset(&sa.sa_mask, SIGTERM);
+	sigaddset(&sa.sa_mask, SIGHUP);
+	sa.sa_flags = flags;
+
+	(void) sigaction(SIGINT, &sa, NULL);
+	(void) sigaction(SIGTERM, &sa, NULL);
+	(void) sigaction(SIGHUP, &sa, NULL);
+}
+
+static int do_listen()
+{
+	int servsock;
+	struct sockaddr_un sockaddr;
+	
+	if ((servsock = socket(AF_LOCAL, SOCK_STREAM, 0)) < 0)
+		return -1;
+
+	unlink(APT_PIPE_PATH);
+	memset(&sockaddr, 0, sizeof(sockaddr));
+	sockaddr.sun_family = AF_LOCAL;
+	strncpy(sockaddr.sun_path, APT_PIPE_PATH, sizeof(sockaddr.sun_path));
+	if (bind(servsock, (struct sockaddr *)&sockaddr, sizeof(sockaddr)) < 0)
+		return -1;
+
+	return ((listen(servsock, 1)) < 0 ? -1 : servsock);
+}
+
+static ssize_t recv_query(int sock, void *buf, size_t bufsize, int *fd)
+{
+	struct msghdr msg;
+	struct iovec iov[1];
+	ssize_t	received = 0;
+	
+	union {
+		struct cmsghdr cm;
+		char control[CMSG_SPACE(sizeof(int))];
+	} control_un;
+	struct cmsghdr	*cmsg;
+
+	msg.msg_name = NULL;
+	msg.msg_namelen = 0;
+
+	iov[0].iov_base = buf;
+	iov[0].iov_len = bufsize;
+	msg.msg_iov = iov;
+	msg.msg_iovlen = 1;
+
+	msg.msg_control = control_un.control;
+	msg.msg_controllen = sizeof(control_un.control);
+
+	if ((received = recvmsg(sock, &msg, MSG_WAITALL)) > 0 &&
+		(cmsg = CMSG_FIRSTHDR(&msg)) != NULL &&
+		cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&
+		cmsg->cmsg_level == SOL_SOCKET &&
+		cmsg->cmsg_type == SCM_RIGHTS)
+		*fd = *((int *) CMSG_DATA(cmsg));
+
+	return(received);
+}
+
+static int send_reply(int sock, char *buf, ssize_t bufsize, int fd)
+{
+	int i, ac;
+	char **av = NULL;
+
+	/* minimal sanity check */
+	if (0 != *(buf + bufsize - 1))
+		return -1;
+
+	/* make fd passed by client our stdout/stderr */
+	dup2(fd, STDOUT_FILENO);
+	dup2(fd, STDERR_FILENO);
+	close(fd);
+
+	/* apt's .Parse skips av[0], so fake it */
+	ac = argz_count(buf, bufsize) + 1;
+	av = (char **)calloc(ac + 1, sizeof(char *));
+	*av = "";
+
+	argz_extract(buf, bufsize, ++av);
+	
+	ac = i = aptpipe_main(ac, (const char **)--av);
+	fflush(stdout);
+	fflush(stderr);
+
+	free(av);
+
+	if ((fd = open("/dev/null", O_RDWR)) < 0)
+		return 1;
+
+	dup2(fd, STDOUT_FILENO);
+	dup2(fd, STDERR_FILENO);
+	close(fd);
+
+	i = (i < 0);
+	ac = (ac > 0);
+
+	/* send last reply later */
+	if (!ac)
+		write(sock, &i, sizeof(int));
+
+	return(ac);
+}
+
+static int mainloop(int servsock) {
+	int cl;
+	int done = 0;
+	char buf[65536];
+
+	while(!signalled && !done) {
+		int fd = -1;
+		size_t received;
+
+		/* TODO check for pending errors on socket */
+
+		/* enable EINTR while in accept */
+		set_sighandler(0);
+		if((cl = accept(servsock, NULL, 0)) < 0) continue;
+
+		set_sighandler(SA_RESTART);
+		if ((received = recv_query(cl, buf, sizeof(buf), &fd)) > 0 && fd != -1)
+			done = send_reply(cl, buf, received, fd);
+		if (!done)
+			close(cl);
+	}
+
+	close(servsock);
+	return(cl);
+}
+
+static int daemonize()
+{
+	pid_t pid;
+	int i, fd;
+	int fds[2] = {-1, -1};
+
+	if (pipe(fds) < 0)
+		return -1;
+
+	if ((pid = fork()) < 0)
+		return -1;
+
+	if (pid) {
+		/* parent */
+		close(fds[1]);
+		/* get child's status */
+		if (read(fds[0], &i, (sizeof(int))) != sizeof(int))
+			return -1;
+		return i;
+	}
+
+	/* child */
+	close(fds[0]);
+	setsid();
+	chdir("/");
+	while (fds[1] <= 2) {
+		fds[1] = dup(fds[1]);
+		if (fds[1] < 0)
+			exit(1);
+	}
+	
+	if ((fd = open("/dev/null", O_RDWR)) < 0)
+		exit(1);
+
+	dup2(fd, 0);
+	dup2(fd, 1);
+	dup2(fd, 2);
+
+	/* closeall */
+	i = sysconf (_SC_OPEN_MAX);
+	for (fd = 3; fd < i; fd++) 
+		if (fd != fds[1])
+			close (fd);
+
+	/* ignore some signals */
+	signal(SIGHUP, SIG_IGN);
+	signal(SIGPIPE, SIG_IGN);
+	signal(SIGUSR1, SIG_IGN);
+	signal(SIGUSR2, SIG_IGN);
+	/* no EINTR please */
+	set_sighandler(SA_RESTART);
+
+	/* open listening socket */
+	if ((fd = do_listen()) < 0)
+		exit(1);
+
+	/* init apt */
+	if (aptpipe_init() < 0)
+		exit(1);
+
+	/* clean up proc title */
+	setproctitle("%s", "ready");
+
+	/* we're still alive, notify parent */
+	i = 0;
+	write(fds[1], &i, sizeof(int));
+	close(fds[1]);
+
+	/* enter main loop */
+	fd = mainloop(fd);
+
+	/* cleanup */
+	aptpipe_fini();
+	unlink(APT_PIPE_PATH);
+	if (fd)
+		write(fd, &i, sizeof(int));
+	exit(EXIT_SUCCESS);
+}
+
+/* ----------------------------------------------------------------------------
+   client
+*/
+static int do_connect()
+{
+	int sock;
+	struct sockaddr_un servaddr;
+
+	if ((sock = socket(AF_LOCAL, SOCK_STREAM, 0)) < 0)
+		return sock;
+
+	memset(&servaddr, 0, sizeof(servaddr));
+	servaddr.sun_family = AF_LOCAL;
+	strncpy(servaddr.sun_path, APT_PIPE_PATH, sizeof(servaddr.sun_path));
+	for(;;) {
+		if (connect(sock, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0) {
+			/* ENOENT ECONNREFUSED : (re)spawn daemon */
+			if (errno == ENOENT || errno == ECONNREFUSED) {
+				if (daemonize() < 0) {
+					fprintf(stderr, "daemonize(): %s\n", strerror(errno));
+					exit(1);
+				}
+				continue;
+			} else {
+				/* EACCESS etc -- just die */
+				fprintf(stderr, "connect(): %s\n", strerror(errno));
+				exit(1);
+			}
+		}
+		break;
+	}
+
+	return sock;
+}
+
+static ssize_t send_query(int fd, int ac, char *av[])
+{
+	int i;
+	struct msghdr msg;
+	struct iovec *iov = NULL;
+
+	union {
+		struct cmsghdr cm;
+		char control[CMSG_SPACE(sizeof(int))];
+	} control_un;
+	struct cmsghdr	*cmsg;
+
+	msg.msg_name = NULL;
+	msg.msg_namelen = 0;
+
+	if ((iov = (struct iovec *)calloc(ac, sizeof(struct iovec))) == NULL)
+		return -1;
+
+	msg.msg_iov = iov;
+	msg.msg_iovlen = ac;
+
+	for (i=0; i < ac; iov++, i++) {
+		iov->iov_base = (void *)av[i];
+		iov->iov_len = strlen(av[i]) + 1;
+	}
+
+	/* keep final 0 for a while */
+	(--iov)->iov_len--;
+
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+
+	if (sendmsg(fd, &msg, 0) < 0)
+		return -1;
+
+	/* pass fd and final 0 */
+	i = 0;
+	iov = msg.msg_iov;
+	iov->iov_base = &i;
+	iov->iov_len = 1;
+	msg.msg_iovlen = 1;
+	
+	msg.msg_control = control_un.control;
+	msg.msg_controllen = sizeof(control_un.control);
+
+	cmsg = CMSG_FIRSTHDR(&msg);
+	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
+	cmsg->cmsg_level = SOL_SOCKET;
+	cmsg->cmsg_type = SCM_RIGHTS;
+	*((int *) CMSG_DATA(cmsg)) = STDOUT_FILENO;
+
+	return (sendmsg(fd, &msg, 0));
+}
+
+static int recv_reply(int fd)
+{
+	int i;
+
+	if (read(fd, &i, (sizeof(int))) != sizeof(int))
+		return -1;
+	return i;
+}
+
+/*----------------------------------------------------------------------------*/
+int main(int ac, char *av[])
+{
+	int i, fd;
+
+	if (ac < 2) {
+		fprintf(stderr, "usage: %s <query>\n", av[0]);
+		exit(EXIT_FAILURE);
+	}
+
+	if ((fd = do_connect()) < 0) {
+		fprintf(stderr, "do_connect: %s\n", strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	/* pass our query in av[] and stdout fd to server */
+	if (send_query(fd, --ac, ++av) < 0) {
+		fprintf(stderr, "send_query: %s\n", strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	/* wait for status responce
+	   actual server reply will be passed via passed stdout */
+	if ((i = recv_reply(fd)) < 0) {
+		fprintf(stderr, "recv_reply\n");
+		exit(EXIT_FAILURE);
+	}
+
+	return i;
+}
diff --git a/cmdline/apt-shell.cc b/cmdline/apt-shell.cc
index 6d1f767..b98976b 100644
--- a/cmdline/apt-shell.cc
+++ b/cmdline/apt-shell.cc
@@ -1,4 +1,4 @@
-// -*- mode: cpp; mode: fold -*-
+// -*- mode: c++; mode: folding -*-
 // Description								/*{{{*/
 // $Id: apt-get.cc,v 1.126 2003/02/12 16:14:08 doogie Exp $
 /* ######################################################################
@@ -25,6 +25,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include <apt-pkg/error.h>
 #include <apt-pkg/cmndline.h>
 #include <apt-pkg/init.h>
@@ -40,7 +42,6 @@
 #include <apt-pkg/sptr.h>
 #include <apt-pkg/versionmatch.h>
 
-#include <config.h>
 #include <apti18n.h>
 
 // CNC:2003-03-17
@@ -65,8 +66,10 @@
 #include <regex.h>
 #include <sys/wait.h>
 
+#ifndef APT_PIPE
 #include <readline/readline.h>
 #include <readline/history.h>
+#endif
 #include <fnmatch.h>
 									/*}}}*/
 
@@ -145,8 +148,11 @@ class AutoReOpenCache
    {
       if (Guarded) {
 	 delete *Cache;
+	 if (_error->PendingError())
+		 _error->PushState();
 	 *Cache = new CacheFile;
 	 (*Cache)->Open();
+	 _error->PopState();
 	 if ((*Cache)->CheckDeps(true) == false) {
 	    c1out << _("There are broken packages. ")
 		  << _("Run `check' to see them.") << endl;
@@ -824,7 +830,7 @@ bool ShowChanges(CacheFile &Cache,pkgDepCache::State *State=NULL)
 	 ioprintf(c1out,_("After unpacking will need more %sB of disk space.\n"),
 		  SizeToStr(UsrSize).c_str());
       else
-	 ioprintf(c1out,_("After unpacking will need less %sB of disk space.\n"),
+	 ioprintf(c1out,_("After unpacking %sB disk space will be freed.\n"),
 		  SizeToStr(-1*UsrSize).c_str());
    } else {
       double DebBytes = Cache->DebSize();
@@ -1100,10 +1106,7 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
 		 " ?] "),Prompt);
       c2out << flush;
       if (AnalPrompt(Prompt) == false)
-      {
-	 c2out << _("Abort.") << endl;
-	 exit(1);
-      }     
+	 return _error->Error(_("Operation cancelled."));
    }
    else
    {      
@@ -1119,10 +1122,7 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
 	    c2out << _("Do you want to continue? [Y/n] ") << flush;
 	 
 	    if (YnPrompt() == false)
-	    {
-	       c2out << _("Abort.") << endl;
-	       exit(1);
-	    }     
+	       return _error->Error(_("Operation cancelled."));
 	 }	 
       }      
    }
@@ -1285,14 +1285,28 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
    if (Cache[Pkg].CandidateVer == 0 && Pkg->ProvidesList != 0)
    {
       vector<pkgCache::Package *> GoodSolutions;
+      unsigned long Size = 0;
       for (pkgCache::PrvIterator Prv = Pkg.ProvidesList();
 	   Prv.end() == false; Prv++)
+	 Size++;
+      SPtrArray<pkgCache::Package *> PList = new pkgCache::Package *[Size];
+      pkgCache::Package **PEnd = PList;
+      for (pkgCache::PrvIterator Prv = Pkg.ProvidesList(); Prv.end() == false; Prv++)
+         *PEnd++ = Prv.OwnerPkg();
+      Fix.MakeScores();
+      qsort(PList,PEnd - PList,sizeof(*PList),&(Fix.ScoreSort));
+
+      for (unsigned int p=0; p<Size; ++p)
       {
-	 pkgCache::PkgIterator PrvPkg = Prv.OwnerPkg();
+         bool instVirtual = _config->FindB("APT::Install::Virtual", false);
+         pkgCache::PkgIterator PrvPkg = pkgCache::PkgIterator(*Pkg.Cache(), PList[p]);
+	 pkgCache::PrvIterator Prv = Pkg.ProvidesList();
+         for (; Prv.end() == false && Prv.OwnerPkg() != PrvPkg; Prv++)
+	    ;
 	 // Check if it's a different version of a package already
 	 // considered as a good solution.
 	 bool AlreadySeen = false;
-	 for (int i = 0; i != GoodSolutions.size(); i++)
+	 for (unsigned int i = 0; i != GoodSolutions.size(); i++)
 	 {
 	    pkgCache::PkgIterator GoodPkg(Cache, GoodSolutions[i]);
 	    if (PrvPkg == GoodPkg)
@@ -1310,6 +1324,8 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
 	    // the user might try to install something he already has
 	    // without being aware.
 	    GoodSolutions.push_back(PrvPkg);
+	    if (instVirtual)
+		break;
 	    continue;
 	 }
 	 pkgCache::VerIterator PrvPkgCandVer =
@@ -1328,7 +1344,7 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
 	 }
       }
       vector<string> GoodSolutionNames;
-      for (int i = 0; i != GoodSolutions.size(); i++)
+      for (unsigned int i = 0; i != GoodSolutions.size(); i++)
       {
 	 pkgCache::PkgIterator GoodPkg(Cache, GoodSolutions[i]);
 	 GoodSolutionNames.push_back(GoodPkg.Name());
@@ -1377,7 +1393,7 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
       {
 	 ioprintf(c1out,_("Package %s is a virtual package provided by:\n"),
 		  Pkg.Name());
-	 for (int i = 0; i != GoodSolutions.size(); i++)
+	 for (unsigned int i = 0; i != GoodSolutions.size(); i++)
 	 {
 	    pkgCache::PkgIterator GoodPkg(Cache, GoodSolutions[i]);
 	    if (GoodPkg.CurrentVer().end() == false)
@@ -1504,12 +1520,15 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
    {
       if (_config->FindB("APT::Get::ReInstall",false) == true)
       {
-	 if (Pkg->CurrentVer == 0 || Pkg.CurrentVer().Downloadable() == false)
-	    ioprintf(c1out,_("Reinstallation of %s is not possible, it cannot be downloaded.\n"),
+	 if (Pkg->CurrentVer == 0)
+	    ioprintf(c1out,_("Reinstallation of %s is not possible.\n"),
 		     Pkg.Name());
+	 else if (Pkg.CurrentVer().Downloadable() == false)
+	    ioprintf(c1out,_("Reinstallation of %s %s is not possible, it cannot be downloaded.\n"),
+		     Pkg.Name(), Pkg.CurrentVer().VerStr());
 	 else
 	    Cache.SetReInstall(Pkg,true);
-      }      
+      }
       else
       {
 	 if (AllowFail == true)
@@ -1812,7 +1831,7 @@ bool DoUpdate(CommandLine &CmdL)
 #endif
 
    // CNC:2004-04-19
-   if (Failed == false && _config->FindB("APT::Get::Archive-Cleanup",true) == true)
+   if (Failed == false && _config->FindB("APT::Get::Archive-Cleanup",false) == true)
    {
       UpdateLogCleaner Cleaner;
       Cleaner.Go(_config->FindDir("Dir::Cache::archives"), *GCache);
@@ -2062,7 +2081,7 @@ bool DoInstall(CommandLine &CmdL)
 	    if (Hit == true)
 	       continue;
 #endif
-	    return _error->Error(_("Couldn't find package %s"),S);
+	    return _error->Error(_("Couldn't find package %s"), OrigS);
 	 }
 
 	 // Regexs must always be confirmed
@@ -2088,7 +2107,7 @@ bool DoInstall(CommandLine &CmdL)
 	    
 	    // CNC:2003-11-23
 	    ioprintf(c1out,_("Selecting %s for '%s'\n"),
-		     Pkg.Name(),S);
+		     Pkg.Name(), OrigS);
 	    StateGuard->Ignore(Pkg);
 	    
 	    if (VerTag != 0)
@@ -2102,7 +2121,7 @@ bool DoInstall(CommandLine &CmdL)
 	 regfree(&Pattern);
 	 
 	 if (Hit == false)
-	    return _error->Error(_("Couldn't find package %s"),S);
+	    return _error->Error(_("Couldn't find package %s"), OrigS);
       }
       else
       {
@@ -3507,11 +3526,14 @@ bool DoList(CommandLine &CmdL)
 
    bool ShowVersion = _config->FindB("APT::Cache::ShowVersion", false);
    bool ShowSummary = _config->FindB("APT::Cache::ShowSummary", false);
+   std::string MatchSection = _config->Find("APT::Cache::MatchGroup","");
+   bool ShowGroup = _config->FindB("APT::Cache::ShowGroup", false);
 
    const char *PkgName;
+   const char *PkgSection;
    int Matches[Cache->Head().PackageCount];
    int NumMatches = 0;
-   int Len, NameMaxLen = 0, VerMaxLen = 0;
+   int Len = 0, NameMaxLen = 0, VerMaxLen = 0;
    bool Matched;
    for (unsigned int J = 0; J < Cache->Head().PackageCount; J++)
    {
@@ -3524,7 +3546,12 @@ bool DoList(CommandLine &CmdL)
       if (ShowUpgradable &&
 	  (Pkg->CurrentVer == 0 || Cache[Pkg].Upgradable() == false))
 	 continue;
+      PkgSection = Pkg.Section();
+      if (!MatchSection.empty() && MatchSection != std::string(PkgSection))
+	continue;
+      
       PkgName = Pkg.Name();
+
       if (MatchAll == true)
 	 Matched = true;
       else for (int i=0; i != NumPatterns; i++) {
@@ -3629,6 +3656,7 @@ bool DoList(CommandLine &CmdL)
       Blank[ColumnLen] = 0;
 
       const char *Str;
+      const char *PkgSection;
       int StrLen;
       unsigned int K;
       for (unsigned int Line = 0; Line != NumLines; Line++) {
@@ -3638,13 +3666,33 @@ bool DoList(CommandLine &CmdL)
 	       break;
 	    pkgCache::PkgIterator Pkg(Cache,Cache.List[Matches[K]]);
 	    Str = Pkg.Name();
+	    PkgSection = Pkg.Section();
 	    StrLen = strlen(Str);
-	    if (Len < ColumnLen-1)
-	       c2out << Str << Blank+StrLen;
-	    else
-	       c2out << Str << " ";
+    	    string status = "available";
+	    if (Pkg->CurrentVer != 0) status = "installed";
+            if (Pkg->CurrentVer != 0)
+              for (pkgCache::DepIterator D = Pkg.RevDependsList(); D.end() == false; D++)
+               {
+	          pkgCache::PkgIterator P = D.ParentPkg();
+                  if ((P->Flags & pkgCache::Flag::Essential) != pkgCache::Flag::Essential &&
+	          (P->Flags & pkgCache::Flag::Important) != pkgCache::Flag::Important)
+	             continue;
+	          status = "locked";
+               }
+	    if (Pkg->CurrentVer != 0 && Cache[Pkg].Upgradable() == true) status = "upgradable";
+	    if (Cache[Pkg].NewInstall()) status = "be-installed";
+	    if (Cache[Pkg].Delete()) status = "be-removed";
+	    if (Cache[Pkg].Upgrade() == true && Cache[Pkg].NewInstall() != true) status = "be-upgraded";
+           if (ShowGroup)
+		c2out << PkgSection << "\t" << Str << endl;
+	   else
+	    {
+	        c2out << Str;
+		if (!MatchSection.empty())
+		    cout << "\t" << status;
+		cout << endl;
+	    }
 	 }
-	 c2out << endl;
       }
    }
    
@@ -3699,9 +3747,7 @@ bool ShowPackage(CommandLine &CmdL)
         return true;
    return _error->Error(_("No packages found"));
 }
-									/*}}}*/
-// --- End of stuff from apt-cache.
-
+/*}}}*/
 
 // ShowHelp - Show a help screen					/*{{{*/
 // ---------------------------------------------------------------------
@@ -3769,7 +3815,7 @@ bool ShowHelp(CommandLine &CmdL)
       "   remove - Remove packages\n"
       "   keep - Keep packages\n"
       "   upgrade - Perform a global upgrade\n"
-      "   dist-upgrade - Perform a globla distribution upgrade\n"
+      "   dist-upgrade - Perform a global distribution upgrade\n"
       "   build-dep - Install build-dependencies for source packages\n"
 //      "   dselect-upgrade - Follow dselect selections\n"
       "   update - Retrieve new lists of packages\n"
@@ -3985,6 +4031,8 @@ void CommandHelp(const char *Name)
 	    "  -u  Show only installed packages that are upgradable.\n"
 	    "  -v  Show installed and candidate versions.\n"
 	    "  -s  Show summaries.\n"
+	    "  -g  Show packages with group name.\n"
+	    "  -G=? Show packages in specified group.\n"
 	    "  -o=? Set an arbitary configuration option, eg -o dir::cache=/tmp\n"
 	    "\n"
 	 );
@@ -4036,7 +4084,9 @@ bool DoCommit(CommandLine &CmdL)
       _error->Error(_("You have no permissions for that"));
       return false;
    }
-   return InstallPackages(*GCache,false);
+   int err = InstallPackages(*GCache,false);
+   _config->Set("APT::Get::Fix-Broken",false);
+   return err;
 }
 
 bool DoStatus(CommandLine &CmdL)
@@ -4078,6 +4128,7 @@ void SigWinch(int)
 }
 									/*}}}*/
 
+#ifndef APT_PIPE
 // ReadLine* - readline library stuff					/*{{{*/
 // ---------------------------------------------------------------------
 /* */
@@ -4087,7 +4138,7 @@ char *ReadLineCompCommands(const char *Text, int State)
 	 "keep", "dist-upgrade", "dselect-upgrade", "build-dep", "clean",
 	 "autoclean", "check", "help", "commit", "exit", "quit", "status",
 	 "showpkg", "unmet", "search", "depends", "whatdepends", "rdepends",
-	 "show", "script", 0};
+	 "show", "script", "list", "ls", 0};
    static int Last;
    static int Len;
    if (State == 0) {
@@ -4245,6 +4296,7 @@ void ReadLineFinish()
       write_history(History.c_str());
 }
 									/*}}}*/
+#endif
 
 CommandLine::Args *CommandArgs(const char *Name)
 {
@@ -4320,11 +4372,17 @@ CommandLine::Args *CommandArgs(const char *Name)
       {'i',"installed","APT::Cache::ShowInstalled",0},
       {'v',"version","APT::Cache::ShowVersion",0},
       {'s',"summary","APT::Cache::ShowSummary",0},
+      {'g',"showgroup","APT::Cache::ShowGroup",0},
+      {'G',"groupmember","APT::Cache::MatchGroup",CommandLine::HasArg},
       {'n',"installed","APT::Cache::Installed",0},
       {'c',"config-file",0,CommandLine::ConfigFile},
       {'o',"option",0,CommandLine::ArbItem},
       {0,0,0,0}};
 
+   static CommandLine::Args UpdateArgs[] = {
+      {'q',"quiet","quiet",CommandLine::IntLevel},
+      {0,0,0,0}};
+
    static CommandLine::Args NoArgs[] = {
       {'h',"help","help",0},
       {'v',"version","version",0},
@@ -4358,11 +4416,146 @@ CommandLine::Args *CommandArgs(const char *Name)
       case 655: // ls
 	 return ListArgs;
 
+   case 451231: // update
+	   return UpdateArgs;
+	   
       default:
 	 return NoArgs;
    }
 }
 									/*}}}*/
+
+#ifdef APT_PIPE
+bool DumpConfig(CommandLine &CmdL)
+{
+	_config->Dump(cout);
+	return true;
+}
+
+bool DoErrors(CommandLine &CmdL)
+{
+	if (_error->empty() == false) {
+		_error->DumpErrors();
+	}
+
+	return true;
+}
+
+extern "C" {
+	int aptpipe_init(void);
+	int aptpipe_main(int ac, const char *av[]);
+	int aptpipe_fini(void);
+}
+
+int aptpipe_init(void)
+{
+	// initialize config
+	CommandLine CmdL(CommandArgs(""), _config);
+
+	// Setup the output streams
+	c0out.rdbuf(devnull.rdbuf());
+	c1out.rdbuf(cout.rdbuf());
+	c2out.rdbuf(cout.rdbuf());
+
+	// Initialize the package library
+	if (pkgInitConfig(*_config) == false ||
+		pkgInitSystem(*_config, _system) == false) {
+		_error->DumpErrors();
+		return 100;
+	}
+
+	// add our nasty defaults
+	_config->Set("Acquire::CDROM::Copy", "false");
+	_config->Set("Acquire::CDROM::Copy-All", "false");
+
+	// Prepare the cache
+	GCache = new CacheFile();
+	GCache->Open();
+
+	if (_error->empty() == false) {
+		bool Errors = _error->PendingError();
+		_error->DumpErrors();
+		return Errors == true?100:0;
+	}
+
+	// TODO check for unmets
+
+#ifdef WITH_LUA
+	_lua->SetDepCache(*GCache);
+	_lua->RunScripts("Scripts::AptShell::Init");
+	_lua->ResetCaches();
+	bool HasCmdScripts = (_lua->HasScripts("Scripts::AptGet::Command") ||
+						  _lua->HasScripts("Scripts::AptCache::Command"));
+#endif
+
+	return 0;
+}
+
+int aptpipe_main(int ac, const char *av[])
+{
+	int rc;
+	CommandLine::Dispatch Cmds[] = {
+		{"update", &DoUpdate},
+		{"upgrade", &DoUpgrade},
+		{"install", &DoInstall},
+		{"remove", &DoInstall},
+		{"keep", &DoInstall},
+		{"dist-upgrade", &DoDistUpgrade},
+		{"dselect-upgrade", &DoDSelectUpgrade},
+		{"build-dep", &DoBuildDep},
+		{"clean", &DoClean},
+		{"autoclean", &DoAutoClean},
+		{"check", &DoCheck},
+		{"help", &ShowHelp},
+		{"commit", &DoCommit},
+		{"quit", &DoQuit},
+		{"exit", &DoQuit},
+		{"status", &DoStatus},
+		{"script", &DoScript},
+		{"errors", &DoErrors},
+		// apt-cache
+		{"showpkg", &DumpPackage},
+		{"unmet", &UnMet},
+		{"search", &Search},
+		{"list", &DoList},
+		{"ls", &DoList},
+		{"depends", &Depends},
+		{"whatdepends", &WhatDepends},
+		{"rdepends", &RDepends},
+		{"show", &ShowPackage},
+		// apt-config
+		{"dumpconfig", &DumpConfig},
+		{0, 0}
+	};
+
+	// Make our own copy of the configuration.
+	Configuration _Config(*_config);
+
+	delete _config;
+	_config = new Configuration(_Config);
+
+	// Parse skips av[0]
+	CommandLine CmdL(CommandArgs(av[1]), _config);
+	CmdL.Parse(ac, av);
+	CmdL.DispatchArg(Cmds);
+
+	rc = (_error->PendingError() == false ?
+		  ((_config->FindB("quit") == true) ? 1 : 0) : -1);
+
+	// restore saved config
+	delete _config;
+	_config = new Configuration(_Config);
+
+	return rc;
+}
+
+int aptpipe_fini()
+{
+   delete GCache;
+   return 0;
+}
+
+#else
 int main(int argc,const char *argv[])
 {
    CommandLine::Dispatch Cmds[] = {{"update",&DoUpdate},
@@ -4401,8 +4594,8 @@ int main(int argc,const char *argv[])
    // Parse the command line and initialize the package library
    CommandLine CmdL(CommandArgs(""),_config);
    if (pkgInitConfig(*_config) == false ||
-       CmdL.Parse(argc,argv) == false ||
-       pkgInitSystem(*_config,_system) == false)
+       pkgInitSystem(*_config,_system) == false ||
+       CmdL.Parse(argc,argv) == false)
    {
       if (_config->FindB("version") == true)
 	 ShowHelp(CmdL);
@@ -4451,6 +4644,7 @@ int main(int argc,const char *argv[])
    // Make a copy of the configuration. Each command will modify its
    // own copy of the whole configuration.
    Configuration GlobalConfig(*_config);
+   Configuration _Config(*_config);
 
    ReadLineInit();
    c1out << _("Welcome to the APT shell. Type \"help\" for more information.") << endl;
@@ -4464,7 +4658,7 @@ int main(int argc,const char *argv[])
 			 _lua->HasScripts("Scripts::AptCache::Command"));
 #endif
 
-   int largc;
+   unsigned int largc;
    const char *largv[1024];
    char *line, *p, *q;
    largv[0] = "";
@@ -4477,10 +4671,18 @@ int main(int argc,const char *argv[])
       }
       
       line = readline(_config->Find("APT::Shell::Prompt", "apt> ").c_str());
-      if (!line || !*line) {
-	 free(line);
-	 continue;
+      if (!line) {
+        c1out << endl;
+        // exit from shell by EOF
+         _config->Set("quit", "true");
+         continue;
+      }
+
+      if (!*line) {
+         free(line);
+         continue;
       }
+
       add_history(line);
 
       largc = 1; // CommandLine.Parse() ignores the first option.
@@ -4536,8 +4738,8 @@ int main(int argc,const char *argv[])
       largv[largc] = 0;
       
       // Make our own copy of the configuration.
-      delete _config;
-      _config = new Configuration(GlobalConfig);
+      //delete _config;
+      //_config = new Configuration(GlobalConfig);
 
       // Prepare the command line
       CommandLine CmdL(CommandArgs(largv[1]),_config);
@@ -4565,6 +4767,12 @@ int main(int argc,const char *argv[])
 	 CmdL.DispatchArg(Cmds);
       
       free(line);
+      if (!_config->FindB("quit"))
+      {
+        // restore saved config
+        delete _config;
+        _config = new Configuration(_Config);
+      }
    }
 
    ReadLineFinish();
@@ -4581,5 +4789,5 @@ int main(int argc,const char *argv[])
    
    return 0;   
 }
-
+#endif
 // vim:sts=3:sw=3
diff --git a/cmdline/indexcopy.cc b/cmdline/indexcopy.cc
index 06be8d9..419a606 100644
--- a/cmdline/indexcopy.cc
+++ b/cmdline/indexcopy.cc
@@ -10,6 +10,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include "indexcopy.h"
 
 #include <apt-pkg/error.h>
diff --git a/cmdline/rpmindexcopy.cc b/cmdline/rpmindexcopy.cc
index 8697317..459517a 100644
--- a/cmdline/rpmindexcopy.cc
+++ b/cmdline/rpmindexcopy.cc
@@ -1,4 +1,6 @@
 
+#include <config.h>
+
 #include <apt-pkg/error.h>
 #include <apt-pkg/progress.h>
 #include <apt-pkg/strutl.h>
diff --git a/configure.in b/configure.in
index 00366c5..5cb6d06 100644
--- a/configure.in
+++ b/configure.in
@@ -11,8 +11,6 @@ AM_MAINTAINER_MODE
 
 AC_CONFIG_HEADER([include/config.h:buildlib/config.h.in])
 
-AC_PROG_LIBTOOL
-
 dnl Check our C compiler
 AC_PROG_CC
 AM_PROG_CC_C_O
@@ -21,6 +19,15 @@ AC_ISC_POSIX
 dnl Check for other programs
 AC_PROG_CXX
 AC_PROG_CPP
+AC_SYS_LARGEFILE
+
+case "$ac_cv_sys_file_offset_bits" in
+	no | unknown) FILE_OFFSET_BITS_SUFFIX=;;
+	*) FILE_OFFSET_BITS_SUFFIX="-$ac_cv_sys_file_offset_bits";;
+esac
+AC_SUBST(FILE_OFFSET_BITS_SUFFIX)
+
+AC_PROG_LIBTOOL
 
 dnl Checks for sockets
 SAVE_LIBS="$LIBS"
@@ -72,7 +79,7 @@ else
 		[AC_MSG_ERROR([Can't find libbz2 library])])
    AC_CHECK_LIB(z,gzopen, [],
 		[AC_MSG_ERROR([Can't find libz library])])
-   AC_CHECK_HEADERS(db1/db.h)
+   dnl AC_CHECK_HEADERS(db1/db.h)
 
    CPPFLAGS="$CPPFLAGS -I/usr/include/rpm"
    AC_CHECK_HEADER(rpm/rpmlib.h, [],
@@ -80,12 +87,13 @@ else
 
    if test $RPM_VERSION_MAJOR -lt 4; then
       RPMLIBS="-lrpm -lz -lbz2 -lpopt"
+      AC_CHECK_HEADERS(db1/db.h)
    else
       AC_CHECK_LIB(rpmdb,rpmdbOpen,
          [RPMDBLIBS="-lrpmdb"],
-         [RPMDBLIBS="-ldb-3.1"],
+         [RPMDBLIBS="-ldb"],
          [-lrpm -lrpmio -lz -lbz2 -lpopt])
-      RPMLIBS="-lrpm $RPMDBLIBS -lrpmio -lz -lbz2 -lpopt"
+      RPMLIBS="-lrpm -lrpmio $RPMDBLIBS"
    fi
    AC_MSG_CHECKING(for RPM libraries)
    AC_MSG_RESULT($RPMLIBS)
@@ -134,10 +142,9 @@ else
 fi
 
 dnl Check for apt-shell dependencies
-AC_CHECK_LIB(ncurses,tputs,
-  [AC_CHECK_HEADER(readline/readline.h,
-     [AC_CHECK_LIB(readline,rl_completion_matches,
-        [compile_aptshell=yes],,[-lncurses])])])
+AC_CHECK_HEADER(readline/readline.h,
+   [AC_CHECK_LIB(readline,rl_completion_matches,
+      [compile_aptshell=yes])])
 AM_CONDITIONAL(COMPILE_APTSHELL, test "$compile_aptshell" = "yes")
 
 dnl Converts the ARCH to be something singular for this general CPU family
@@ -233,7 +240,7 @@ fi
 AM_CONDITIONAL(COMPILE_MANPAGES, test -n "$DOCBOOK2MAN" -a "$enable_docs" != "no")
 
 AM_GNU_GETTEXT_VERSION([0.11.4])
-AM_GNU_GETTEXT
+AM_GNU_GETTEXT([external])
 
 dnl ah_NUM_PROCS
 rc_GLIBC_VER
@@ -252,7 +259,6 @@ AC_OUTPUT([
 	  Makefile
 	  buildlib/Makefile
 	  intl/Makefile 
-	  lua/Makefile
 	  apt-pkg/Makefile
 	  methods/Makefile
 	  cmdline/Makefile
diff --git a/contrib/apt-wrapper/apt b/contrib/apt-wrapper/apt
index 4241971..a85ccc3 100644
--- a/contrib/apt-wrapper/apt
+++ b/contrib/apt-wrapper/apt
@@ -55,7 +55,7 @@ while [ $# -gt 0 ]; do
 		;;
 
 	update|upgrade|install|remove|dist-upgrade|\
-	  build-dep|clean|autoclean|check|source|moo|script|reinstall|\
+	  build-dep|clean|autoclean|check|source|script|reinstall|\
 	  groupinstall|groupremove)
 		APTCMD=apt-get
 		break
diff --git a/contrib/apt-wrapper/apt.1 b/contrib/apt-wrapper/apt.1
index c1b38a2..f2f43a5 100644
--- a/contrib/apt-wrapper/apt.1
+++ b/contrib/apt-wrapper/apt.1
@@ -42,7 +42,7 @@ Detailed information about each apt command and its options can be found in the
 .SH "ACTIONS"
 
 .PP
-Actions supported by \fBapt\fR: add, autoclean, build\-dep, check, clean, depends, dist\-upgrade, dotty, dump, dumpavail, gencaches, groupinstall, groupremove, ident, install, list\-extras, list\-nodeps, moo, pkgnames, policy, query, querytags, rdepends\&. reinstall\&. remove, script, search, show, showgroup, showgroups, showpkg, showsrc, source, stats, unmet, update, upgrade, whatdepends, xvcg\&.
+Actions supported by \fBapt\fR: add, autoclean, build\-dep, check, clean, depends, dist\-upgrade, dotty, dump, dumpavail, gencaches, groupinstall, groupremove, ident, install, list\-extras, list\-nodeps, pkgnames, policy, query, querytags, rdepends\&. reinstall\&. remove, script, search, show, showgroup, showgroups, showpkg, showsrc, source, stats, unmet, update, upgrade, whatdepends, xvcg\&.
 
 .TP
 groupinstall
@@ -81,7 +81,7 @@ The functionality of the remaining actions are provided by other apt tools\&. Th
 
 .TP
 \fBapt\-get\fR
-autoclean, build\-dep, check, clean, dist\-upgrade, install, moo, remove, reinstall\&. script, source, update, upgrade\&.
+autoclean, build\-dep, check, clean, dist\-upgrade, install, remove, reinstall\&. script, source, update, upgrade\&.
 
 .TP
 \fBapt\-cache\fR
diff --git a/doc/apt.ent b/doc/apt.ent
index 647c1e5..93f4709 100644
--- a/doc/apt.ent
+++ b/doc/apt.ent
@@ -126,7 +126,9 @@
      <ListItem><Para>
      Configuration File; Specify a configuration file to use. 
      The program will read the default configuration file and then this 
-     configuration file. See &apt-conf; for syntax information.     
+     configuration file. If configuration settings need to be set before the
+     default configuration files are parsed specify a file with the <envar>APT_CONFIG</envar>
+     environment variable. See &apt-conf; for syntax information.
      </Para></ListItem>
      </VarListEntry>
      
diff --git a/methods/Makefile.am b/methods/Makefile.am
index dc0f346..8c09c6e 100644
--- a/methods/Makefile.am
+++ b/methods/Makefile.am
@@ -1,6 +1,6 @@
 
 methodsdir=${libdir}/apt/methods
-methods_PROGRAMS = cdrom copy file ftp gpg gzip bzip2 http rsh ssh
+methods_PROGRAMS = cdrom copy file ftp gpg gzip bzip2 http rsh ssh rsync
 
 LDADD = ../apt-pkg/libapt-pkg.la
 
@@ -12,6 +12,7 @@ gzip_SOURCES = gzip.cc
 bzip2_SOURCES = $(gzip_SOURCES)
 rsh_SOURCES = rsh.cc rsh.h
 ssh_SOURCES = $(rsh_SOURCES)
+rsync_SOURCES = rsync.cc rsync-method.h
 
 http_SOURCES = \
 	       http.cc \
diff --git a/methods/cdrom.cc b/methods/cdrom.cc
index 682f945..c281484 100644
--- a/methods/cdrom.cc
+++ b/methods/cdrom.cc
@@ -8,6 +8,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include <apt-pkg/acquire-method.h>
 #include <apt-pkg/cdromutl.h>
 #include <apt-pkg/error.h>
@@ -78,7 +80,7 @@ string CDROMMethod::PreferredURI()
 	 if (FileExists(DFile) == true)
 	 {
 	    if (ReadConfigFile(Database,DFile) == false) {
-	       _error->Error(_("Unable to read the cdrom database %s"),
+	       _error->Error(_("Unable to read the media database %s"),
 			     DFile.c_str());
 	       return "";
 	    }
@@ -190,7 +192,7 @@ bool CDROMMethod::Fetch(FetchItem *Itm)
       if (FileExists(DFile) == true)
       {
 	 if (ReadConfigFile(Database,DFile) == false)
-	    return _error->Error(_("Unable to read the cdrom database %s"),
+	    return _error->Error(_("Unable to read the media database %s"),
 			  DFile.c_str());
       }
       DatabaseLoaded = true;
@@ -199,8 +201,8 @@ bool CDROMMethod::Fetch(FetchItem *Itm)
    // All non IMS queries for package files fail.
    if (Itm->IndexFile == true || GetID(Get.Host).empty() == true)
    {
-      Fail(_("Please use apt-cdrom to make this CD recognized by APT."
-	   " apt-get update cannot be used to add new CDs"));
+      Fail(_("Please use apt-cdrom to make this media recognized by APT."
+	   " apt-get update cannot be used to add new Media"));
       return true;
    }
 
@@ -240,12 +242,12 @@ bool CDROMMethod::Fetch(FetchItem *Itm)
 	 
       // I suppose this should prompt somehow?
       if (UnmountCdrom(CDROM) == false)
-	 return _error->Error(_("Unable to unmount the CD-ROM in %s, it may still be in use."),
+	 return _error->Error(_("Unable to unmount media in %s, it may still be in use."),
 			      CDROM.c_str());
       if (MediaFail(Get.Host,CDROM) == false)
       {
 	 CurrentID = "FAIL";
-	 Fail(_("Wrong CD"),true);
+	 Fail(_("Wrong media"),true);
 	 return true;
       }
    }
diff --git a/methods/connect.cc b/methods/connect.cc
index 7d5629b..f94dcf8 100644
--- a/methods/connect.cc
+++ b/methods/connect.cc
@@ -11,6 +11,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include "connect.h"
 #include <apt-pkg/error.h>
 #include <apt-pkg/fileutl.h>
diff --git a/methods/copy.cc b/methods/copy.cc
index 3af12a9..9a33611 100644
--- a/methods/copy.cc
+++ b/methods/copy.cc
@@ -9,6 +9,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include <apt-pkg/fileutl.h>
 #include <apt-pkg/acquire-method.h>
 #include <apt-pkg/error.h>
diff --git a/methods/file.cc b/methods/file.cc
index 556ef1d..2e47fb3 100644
--- a/methods/file.cc
+++ b/methods/file.cc
@@ -13,6 +13,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include <apt-pkg/acquire-method.h>
 #include <apt-pkg/error.h>
 
diff --git a/methods/ftp.cc b/methods/ftp.cc
index fda89cb..ab6dd3f 100644
--- a/methods/ftp.cc
+++ b/methods/ftp.cc
@@ -15,6 +15,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include <apt-pkg/fileutl.h>
 #include <apt-pkg/acquire-method.h>
 #include <apt-pkg/error.h>
@@ -190,7 +192,7 @@ bool FTPConn::Login()
    // Setup the variables needed for authentication
    string User = "anonymous";
    // CNC:2003-06-16
-   string Pass = "apt_get_ftp_2.1@rpm.linux.user";
+   string Pass = "apt_get_ftp_2.1@alt.linux.user";
 
    // Fill in the user/pass
    if (ServerName.User.empty() == false)
diff --git a/methods/gpg.cc b/methods/gpg.cc
index 932397f..c52bc3a 100644
--- a/methods/gpg.cc
+++ b/methods/gpg.cc
@@ -1,4 +1,6 @@
 
+#include <config.h>
+
 #include <apt-pkg/error.h>
 #include <apt-pkg/acquire-method.h>
 #include <apt-pkg/strutl.h>
@@ -196,7 +198,7 @@ char *getFileSigner(const char *file, const char *sigfile,
    else if (pid == 0) 
    {
       string path = _config->Find("Dir::Bin::gpg", "/usr/bin/gpg");
-      string pubring = "";
+      string homedir = "";
       const char *argv[16];
       int argc = 0;
       
@@ -207,17 +209,16 @@ char *getFileSigner(const char *file, const char *sigfile,
       dup2(fd[1], STDERR_FILENO);
       
       unsetenv("LANG");
+      unsetenv("LANGUAGE");
       unsetenv("LC_ALL");
       unsetenv("LC_MESSAGES");
+      unsetenv("LC_CTYPE");
 
       argv[argc++] = "gpg";
       argv[argc++] = "--batch";
       argv[argc++] = "--no-secmem-warning";
-      pubring = _config->Find("APT::GPG::Pubring");
-      if (pubring.empty() == false)
-      {
-	 argv[argc++] = "--keyring"; argv[argc++] = pubring.c_str();
-      }
+      homedir = _config->Find("APT::GPG::Homedir", "/usr/lib/alt-gpgkeys");
+      argv[argc++] = "--homedir"; argv[argc++] = homedir.c_str();
       argv[argc++] = "--status-fd"; argv[argc++] = "2";
       
       if (outfile != NULL)
@@ -255,7 +256,8 @@ char *getFileSigner(const char *file, const char *sigfile,
       {
 	 char *sig;
 	 ptr = sig = ptr1 + sizeof(SIGPACK);
-	 while (isxdigit(*ptr) && (ptr-sig) < sizeof(keyid)) ptr++;
+	 while (ptr < sig + sizeof(keyid) && isxdigit(*ptr))
+	    ptr++;
 	 *ptr = 0;
 	 strcpy(keyid, sig);
       }
diff --git a/methods/gzip.cc b/methods/gzip.cc
index ee03b2a..aa1cb22 100644
--- a/methods/gzip.cc
+++ b/methods/gzip.cc
@@ -9,6 +9,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include <apt-pkg/fileutl.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/acquire-method.h>
diff --git a/methods/http.cc b/methods/http.cc
index e9a020e..d27c1b7 100644
--- a/methods/http.cc
+++ b/methods/http.cc
@@ -25,6 +25,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include <apt-pkg/fileutl.h>
 #include <apt-pkg/acquire-method.h>
 #include <apt-pkg/error.h>
diff --git a/methods/rfc2553emu.cc b/methods/rfc2553emu.cc
index 379be22..87c0581 100644
--- a/methods/rfc2553emu.cc
+++ b/methods/rfc2553emu.cc
@@ -14,6 +14,8 @@
 
    ##################################################################### */
 									/*}}}*/
+#include <config.h>
+
 #include "rfc2553emu.h"
 #include <stdlib.h>
 #include <arpa/inet.h>
diff --git a/methods/rsh.cc b/methods/rsh.cc
index a0f34af..3871a42 100644
--- a/methods/rsh.cc
+++ b/methods/rsh.cc
@@ -11,6 +11,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
+#include <config.h>
+
 #include "rsh.h"
 #include <apt-pkg/error.h>
 
diff --git a/methods/rsync-method.h b/methods/rsync-method.h
new file mode 100644
index 0000000..d077a4c
--- /dev/null
+++ b/methods/rsync-method.h
@@ -0,0 +1,116 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+// $Id$
+/* ######################################################################
+
+RSYNC Aquire Method - This is the RSYNC aquire method for APT.
+
+##################################################################### */
+/*}}}*/
+#ifndef APT_RSYNC_H
+#define APT_RSYNC_H
+
+using namespace std;
+
+static const char * RSYNC_PROGRAM = "/usr/bin/rsync";
+
+class Argv
+{
+   int max_size;
+   int size;
+   char **args;
+
+  public:
+   Argv(int msize);
+   ~Argv();
+
+   bool add(const char *arg);
+   bool add(const string &arg) { return add( arg.c_str()); }
+   bool resize();
+   int getSize() { return size; }
+   operator char**() { return args; }
+   operator string();
+};
+
+
+class RsyncMethod : public pkgAcqMethod
+{
+  protected:
+   enum ConnType {ConnTypeExec, ConnTypeExecExt, ConnTypeProto};
+
+   class RsyncConn
+	  {
+		public:
+		 enum ConnState {Idle,Starting,Connecting,Fetching,Failed,Done};
+
+		protected:
+		 URI srv;
+		 const string proxy;
+		 ConnState State;
+
+		 static char proxy_value[1024];
+		 bool initProxy();
+
+		public:
+		 RsyncConn(URI u, const string &_proxy = ""): srv(u), proxy(_proxy) {}
+		 virtual ~RsyncConn() {}
+
+		 virtual bool Get(pkgAcqMethod *Owner, FetchResult &FRes, const char *From, const char *To) = 0;
+	  };
+
+   class RsyncConnExec: public RsyncConn
+	  {
+		 // pid of child process
+		 pid_t ChildPid;
+		 // output of child process (stdout&stderr)
+		 int ChildFd;
+		 // Program to execute
+		 string program;
+
+		protected:
+		 bool WaitChild(pkgAcqMethod *Owner, FetchResult &FRes, const char *To);
+		 virtual void ParseOutput(pkgAcqMethod *Owner, FetchResult &FRes, const char *buf);
+		 virtual void AddOptions(Argv &argv)
+			{ argv.add("-vvvv"); };
+
+		public:
+		 RsyncConnExec(URI u, const string &_proxy, const string &prog);
+		 virtual ~RsyncConnExec();
+
+		 virtual bool Get(pkgAcqMethod *Owner, FetchResult &FRes, const char *From, const char *To);
+	  };
+
+   class RsyncConnExecExt: public RsyncConnExec
+	  {
+		protected:
+		 virtual void ParseOutput(pkgAcqMethod *Owner, FetchResult &FRes, const char *buf);
+		 virtual void AddOptions(Argv &argv)
+			{ argv.add("--apt-support"); };
+
+		public:
+		 RsyncConnExecExt(URI u, const string &_proxy, const string &prog):
+			RsyncConnExec(u, _proxy, prog) {};
+	  };
+
+   static RsyncConn *server;
+   static ConnType connType;
+   static bool Debug;
+   static unsigned int Timeout;
+
+   string RsyncProg;
+
+   static void SigTerm(int);
+
+  protected:
+   virtual bool Fetch(FetchItem *Itm);
+   virtual bool Configuration(string Message);
+
+   void Start(FetchResult &FRes)
+	  { URIStart(FRes); }
+
+  public:
+   
+   RsyncMethod();
+};
+
+#endif
diff --git a/methods/rsync.cc b/methods/rsync.cc
new file mode 100644
index 0000000..4fd8d31
--- /dev/null
+++ b/methods/rsync.cc
@@ -0,0 +1,572 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+// $Id$
+/* ######################################################################
+
+RSYNC Aquire Method - This is the RSYNC aquire method for APT.
+   
+##################################################################### */
+/*}}}*/
+// Include Files							/*{{{*/
+#include <config.h>
+
+#include <apt-pkg/fileutl.h>
+#include <apt-pkg/acquire-method.h>
+#include <apt-pkg/error.h>
+#include <apt-pkg/md5.h>
+
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <utime.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <sys/wait.h>
+#include <iostream>
+
+// Internet stuff
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+
+#include "apti18n.h"
+#include "rfc2553emu.h"
+#include "connect.h"
+#include "rsync-method.h"
+/*}}}*/
+
+RsyncMethod::RsyncConn *RsyncMethod::server = 0;
+RsyncMethod::ConnType RsyncMethod::connType = RsyncMethod::ConnTypeExec;
+bool RsyncMethod::Debug = false;
+unsigned int RsyncMethod::Timeout = 0;
+
+/* Argv implementation */
+Argv::Argv(int msize): max_size(msize), size(0)
+{
+   args = new char*[max_size];
+   memset(args,0, max_size * sizeof(char*));
+}
+
+Argv::~Argv()
+{
+   for (int i=0; i<size; i++)
+	  delete args[i];
+   delete [] args;
+}
+
+bool Argv::add(const char *arg)
+{
+   if (arg==0)
+	  return false;
+   if ( size+1 >= max_size && !resize() ) {
+	  cerr << "Failed to resize" << endl;
+	  return false;
+   }
+   int len = strlen(arg);
+   args[size] = new char[len+1];
+   strncpy(args[size], arg, len+1);
+   ++size;
+   return true;
+}
+
+bool Argv::resize()
+{
+   static const int increment = 5;
+   char **new_args = new char *[max_size+increment];
+   memcpy(new_args,args,size*sizeof(char*));
+   memset(new_args+size,0, (max_size+increment-size) * sizeof(char*));
+   args = new_args;
+   max_size += increment;
+   return true;
+}
+
+Argv::operator string()
+{
+   string res;
+   for (char **p=args; *p; p++)
+	  res += *p, res += " ";
+   return res;
+}
+
+/* RsyncConn implementation */
+
+/** Static buffer for RSYNC_PROXY variable */
+char RsyncMethod::RsyncConn::proxy_value[1024];
+
+bool RsyncMethod::RsyncConn::initProxy()
+{
+   if ( proxy.empty() )
+	  return true;
+   if ( proxy == "none" ) {
+	  unsetenv("RSYNC_PROXY");
+	  return true;
+   }
+   bool res = true;
+   string var("RSYNC_PROXY=");
+   var += proxy;
+   strncpy(proxy_value, var.c_str(), sizeof(proxy_value) );
+   if ( proxy_value[sizeof(proxy_value)-1]==0 ) {
+	  if ( putenv(proxy_value)!=0 ) {
+		 res = false;
+		 _error->Error("Failed to set RSYNC_PROXY: %s", proxy_value);
+	  }
+   } else {
+	  res = false;
+	  _error->Error("Failed to set RSYNC_PROXY: not enough space in buffer");
+   }
+   return res;
+}
+
+/* RsyncConnExec implementation */
+
+RsyncMethod::RsyncConnExec::RsyncConnExec(URI u, const string &_proxy, const string &prog)
+   : RsyncConn(u,_proxy), ChildPid(-1), ChildFd(-1)
+{
+   program = prog.empty() ? RSYNC_PROGRAM : prog;
+}
+
+RsyncMethod::RsyncConnExec::~RsyncConnExec()
+{
+   if ( ChildPid>0 ) {
+	  kill(ChildPid, SIGTERM);
+	  waitpid(ChildPid, 0, 0);
+	  ChildPid = -1;
+   }
+   if ( ChildFd>=0 )
+	  close(ChildFd);
+}
+
+bool RsyncMethod::RsyncConnExec::WaitChild(pkgAcqMethod *Owner, FetchResult &FRes, const char *To)
+{
+   static const int buflen = 1024;
+   static char buf[buflen+1];
+   int saved = 0;
+   int status = 0, res = 0;
+   fd_set readfd;
+   struct timeval tv;
+   if ( RsyncMethod::Debug )
+	  cerr << "RSYNC: WaitChild: fd=" << ChildFd << endl;
+
+   while (1) {
+	  FD_ZERO(&readfd);
+	  FD_SET(ChildFd,&readfd);
+	  FD_SET(0,&readfd);
+
+	  tv.tv_sec = 1;
+	  tv.tv_usec = 0;
+	  res = select(ChildFd+1, &readfd, 0, 0, &tv);
+
+	  if (res>0) {
+		 if ( FD_ISSET(ChildFd,&readfd) ) {
+			int len = read(ChildFd,buf+saved, buflen-saved);
+			if (len>0) {
+			   // Split buffer into single-line strings
+			   // and pass each string to ParseOutput.
+			   // Strings, that are not terminated with '\n' will
+			   // be stored in buffer for later completion.
+			   buf[saved+len] = 0;
+			   int start = 0;
+			   for (int off=saved; off<len; off++) {
+			      if ( buf[off]=='\n' ) {
+					 buf[off] = 0;
+					 ParseOutput(Owner,FRes,buf+start);
+					 start = off+1;
+			      }
+			   }
+			   saved = saved+len-start;
+			   if ( saved==buflen ) {
+			      // Parse process output even it was not terminated with '\n'
+			      // in case of full buffer (we can't read anything if there is
+			      // no free space in buffer).
+			      ParseOutput(Owner,FRes,buf);
+			      saved = 0;
+			   } else if ( saved>0 ) {
+			      if ( RsyncMethod::Debug )
+					 cerr << "RSYNC: Saved " << saved << " byted in buffer:"
+						  << endl << start << endl;
+			      // Move saved data to the beginning of the buffer
+			      // including trailing zero
+			      memmove(buf,buf+start,saved+1);
+			   }
+			}
+		 }
+	  }
+	  res = waitpid(ChildPid, &status, WNOHANG);
+	  if ((res>0 && WIFEXITED(status)) || res<0) {
+		 ChildPid = -1;
+		 if ( RsyncMethod::Debug )
+			cerr << endl << "RSYNC: Closing ChildFd: " << ChildFd << endl;
+		 close(ChildFd);
+		 ChildFd = -1;
+		 // Parse end of process output if it was not terminated with '\n'
+		 if (saved>0)
+			ParseOutput(Owner,FRes,buf);
+		 if (res < 0) {
+		    if ( RsyncMethod::Debug )
+		       cerr << endl << "RSYNC: Unknown status of child process " << ChildFd << endl;
+		    if (State == Done)
+		       return true;
+		    return false;
+		 }
+		 switch (WEXITSTATUS(status)) {
+			case 0:
+			   return true;
+			   break;
+			default:
+			   if ( State != Failed ) {
+				  State = Failed;
+				  _error->Error("rsync process terminated with exit code %d", WEXITSTATUS(status));
+			   }
+			   return false;
+			   break;
+		 }
+	  }
+   }
+   return false;
+}
+
+/* Parse rysnc output
+ * Need to parse lines like:
+ *
+ * ^opening tcp connection to rsync.altlinux.ru port 873
+ * ^[11948] i=0 <NULL> FILENAME mode=0100664 len=171935
+ * ^FILENAME
+ * ^renaming .FILENAME.bWM2bW to FILENAME
+ * ^set modtime of FILENAME to (1048860997) Fri Mar 28 17:16:37 2003
+ * ^recv_files finished
+ *
+ */
+void RsyncMethod::RsyncConnExec::ParseOutput(pkgAcqMethod *Owner, FetchResult &FRes, const char *buf)
+{
+   static const char * TMPFN = "Tmp-Filename: ";
+   static const char * SIZE  = "Size: ";
+   static const char * START = "Start: ";
+   static const char * DONE  = "recv_files finished";
+   static const char * FAILED= "Failed: ";
+   const char * ptr;
+
+   if ( RsyncMethod::Debug )
+     cerr << "ParseOutput: " << buf << endl;
+
+   ptr = strstr(buf,"opening tcp connection");
+   if (ptr) {
+	 if ( RsyncMethod::Debug )
+	   cerr << endl << "Status: Connecting" << endl;
+	 State = Connecting;
+	 Owner->Status(_("Connecting"));
+	 return;
+   }
+
+   // [PID] i=0 DIRNAME FILENAME mode=XXXXXXX len=YYYYYY
+   if (buf[0]=='[') {
+	 ptr = strstr(buf,"i=0 ");
+	 if (ptr == 0) return;
+	 ptr += 4; // skip "i=0 "
+	 ptr = strchr(ptr,' '); // skip DIRNAME
+   }
+
+   ptr = strstr(buf,TMPFN);
+   if (ptr) {
+	  ptr += strlen(TMPFN);
+	  const char *ptr2 = ptr;
+	  while (*ptr2!=0 && !isspace(*ptr2))
+		 ++ptr2;
+	  if (ptr!=ptr2) {
+		 char *tmpfn = new char[ptr2-ptr+1];
+		 bzero(tmpfn, ptr2-ptr+1);
+		 strncpy(tmpfn, ptr, ptr2-ptr);
+		 if (RsyncMethod::Debug)
+			cerr << endl << "RSYNC: " << TMPFN << tmpfn << endl;
+		 FRes.TmpFilename = string(tmpfn);
+		 delete tmpfn;
+	  }
+   }
+  
+   ptr = strstr(buf,SIZE);
+   if (ptr) {
+	  ptr += strlen(SIZE);
+	  unsigned long size = atol(ptr);
+	  if (RsyncMethod::Debug)
+		 cerr << "RSYNC: " << SIZE << size << endl;
+	  FRes.Size = size;
+   }
+
+   ptr = strstr(buf,START);
+   if (ptr) {
+	  State = Fetching;
+	  dynamic_cast<RsyncMethod*>(Owner)->Start(FRes);
+   }
+
+   ptr = strstr(buf,DONE);
+   if (ptr) 
+	  State = Done;
+
+   ptr = strstr(buf,FAILED);
+   if (ptr) {
+	  State = Failed;
+	  ptr += strlen(FAILED);
+	  const char *ptr2 = ptr;
+	  while (*ptr2!=0 && *ptr2!='\n')
+		 ++ptr2;
+	  if (ptr!=ptr2) {
+		 char *tmp = new char[ptr2-ptr+1];
+		 bzero(tmp, ptr2-ptr+1);
+		 strncpy(tmp, ptr, ptr2-ptr);
+		 _error->Error("%s",tmp);
+		 if (RsyncMethod::Debug)
+			cerr << endl << FAILED << tmp << endl;
+		 delete tmp;
+	  } else {
+		 _error->Error("Child process failed (no description)");
+	  }
+   }
+}
+
+bool RsyncMethod::RsyncConnExec::Get(pkgAcqMethod *Owner, FetchResult &FRes, const char *From, const char *To)
+{
+   int p[2];
+   int res = 0;
+   Argv argv(10);
+
+   State = Starting;
+   if ( RsyncMethod::Debug )
+	  cerr << "RSYNC: Get: " << From << endl;
+
+   argv.add(program.c_str());
+   argv.add("-Lpt");
+   argv.add("--partial");
+   AddOptions(argv);
+   if (RsyncMethod::Timeout>0) {
+	  argv.add("--timeout");
+	  char S[10];
+	  sprintf(S,"%u",RsyncMethod::Timeout);
+	  argv.add(S);
+   }
+   // Add optional user-defined options to command line
+   Configuration::Item const *Itm = _config->Tree("Acquire::rsync::options");
+   if (Itm != 0 && Itm->Child != 0) {
+	  Itm = Itm->Child;
+	  while (Itm != 0) {
+		 if (Itm->Value.empty() == false)
+			argv.add(Itm->Value.c_str());
+		 Itm = Itm->Next;
+	  }
+   }
+
+   char port[12];
+   if (srv.Port!=0)
+	  snprintf(port, sizeof(port), ":%u", srv.Port);
+   else port[0] = 0;
+   argv.add( "rsync://" + srv.Host + port + From);
+   argv.add(To);
+
+   if ( pipe(p) ) {
+	  _error->Error("RSYNC: RsyncConnExec: Can't create pipe");
+	  return false;
+   }
+   if ( RsyncMethod::Debug )
+	  cerr << "RSYNC: Created pipe [" << p[0] << ',' << p[1] << ']' << endl;
+   if ( RsyncMethod::Debug )
+	  cerr << "RSYNC: Starting: " << string(argv) << endl;
+
+   switch ( ChildPid = fork() ) {
+	  case -1:
+		 _error->Error("RsyncConnExec: Can't fork");
+		 return false;
+		 break;
+	  case 0:
+		 // Child process
+		 initProxy();
+		 //if ( RsyncMethod::Debug )
+		 //   cerr << endl << "RSYNC_PROXY(" << srv.Host << "): " << getenv("RSYNC_PROXY") << endl;
+		 close(p[0]);
+		 res = dup2(p[1], STDOUT_FILENO);
+		 if (res==-1) {
+			cout << "Failed: " << "Can't dup2(p[1], STDOUT_FILENO)" << endl;
+			exit(100);
+		 }
+		 res = dup2(p[1], STDERR_FILENO);
+		 if (res==-1) {
+			cout << "Failed: " << "Can't dup2(p[1], STDERR_FILENO)" << endl;
+			exit(100);
+		 }
+
+		 close(p[1]);
+		 execve(program.c_str(), argv, environ);
+		 cout << "Failed: " << "Can not execute " << program << endl;
+		 exit(100);
+		 break;
+	  default:
+		 // Parent process
+		 close(p[1]);
+		 ChildFd = p[0];
+		 return WaitChild(Owner,FRes,To);
+   }
+   return false;
+}
+
+// Parse output of rsync process with --apt-support option
+void RsyncMethod::RsyncConnExecExt::ParseOutput(pkgAcqMethod *Owner, FetchResult &FRes, const char *buf)
+{
+   static const char * TMPFN = "Tmp-Filename: ";
+   static const char * SIZE  = "Size: ";
+   static const char * START = "Start: ";
+   static const char * DONE  = "Done: ";
+   static const char * FAILED= "Failed: ";
+   const char * ptr;
+
+   //if ( RsyncMethod::Debug )
+   //  cerr << "ParseOutput: " << buf << endl;
+
+   ptr = strstr(buf,TMPFN);
+   if (ptr) {
+	  ptr += strlen(TMPFN);
+	  const char *ptr2 = ptr;
+	  while (*ptr2!=0 && !isspace(*ptr2))
+		 ++ptr2;
+	  if (ptr!=ptr2) {
+		 char *tmpfn = new char[ptr2-ptr+1];
+		 bzero(tmpfn, ptr2-ptr+1);
+		 strncpy(tmpfn, ptr, ptr2-ptr);
+		 if (RsyncMethod::Debug)
+			cerr << endl << "RSYNC: " << TMPFN << tmpfn << endl;
+		 FRes.TmpFilename = string(tmpfn);
+		 delete tmpfn;
+	  }
+   }
+  
+   ptr = strstr(buf,SIZE);
+   if (ptr) {
+	  ptr += strlen(SIZE);
+	  unsigned long size = atol(ptr);
+	  if (RsyncMethod::Debug)
+		 cerr << "RSYNC: " << SIZE << size << endl;
+	  FRes.Size = size;
+   }
+
+   ptr = strstr(buf,START);
+   if (ptr) {
+	  State = Fetching;
+	  dynamic_cast<RsyncMethod*>(Owner)->Start(FRes);
+   }
+
+   ptr = strstr(buf,DONE);
+   if (ptr) 
+	  State = Done;
+
+   ptr = strstr(buf,FAILED);
+   if (ptr) {
+	  State = Failed;
+	  ptr += strlen(FAILED);
+	  const char *ptr2 = ptr;
+	  while (*ptr2!=0 && *ptr2!='\n')
+		 ++ptr2;
+	  if (ptr!=ptr2) {
+		 char *tmp = new char[ptr2-ptr+1];
+		 bzero(tmp, ptr2-ptr+1);
+		 strncpy(tmp, ptr, ptr2-ptr);
+		 _error->Error("%s",tmp);
+		 if (RsyncMethod::Debug)
+			cerr << endl << FAILED << tmp << endl;
+		 delete tmp;
+	  } else {
+		 _error->Error("Child process failed (no description)");
+	  }
+   }
+}
+
+// RsyncMethod::RsyncMethod - Constructor					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+RsyncMethod::RsyncMethod() : pkgAcqMethod("1.0",SendConfig),
+							 RsyncProg(RSYNC_PROGRAM)
+{
+   signal(SIGTERM,SigTerm);
+   signal(SIGINT,SigTerm);
+}
+/*}}}*/
+// RsyncMethod::SigTerm - Handle a fatal signal				/*{{{*/
+// ---------------------------------------------------------------------
+/* Delete existing server connection */
+void RsyncMethod::SigTerm(int)
+{
+   delete server;
+   _exit(100);
+}
+/*}}}*/
+// RsyncMethod::Configuration - Handle a configuration message		/*{{{*/
+// ---------------------------------------------------------------------
+/* We stash the desired pipeline depth */
+bool RsyncMethod::Configuration(string Message)
+{
+   if (pkgAcqMethod::Configuration(Message) == false)
+	  return false;
+   
+   Debug = _config->FindB("Debug::rsync",false);
+   Timeout = _config->FindI("Acquire::rsync::Timeout",0);
+   RsyncProg = _config->Find("Acquire::rsync::program",RSYNC_PROGRAM);
+   return true;
+}
+/*}}}*/
+// RsyncMethod::Fetch - Fetch a file					/*{{{*/
+// ---------------------------------------------------------------------
+/* Fetch a single file, called by the base class..  */
+bool RsyncMethod::Fetch(FetchItem *Itm)
+{
+   URI Get = Itm->Uri;
+   const char *File = Get.Path.c_str();
+   FetchResult Res;
+   Res.Filename = Itm->DestFile;
+   Res.IMSHit = false;
+
+   struct stat st;
+   if ( stat(Itm->DestFile.c_str(), &st)==0 ) {
+	  Res.ResumePoint = st.st_size;
+   }
+
+   string proxy = _config->Find(string("Acquire::rsync::proxy::")+Get.Host);
+   if ( proxy.empty() )
+	  proxy = _config->Find("Acquire::rsync::proxy");
+
+   if (Debug)
+	  cerr << endl << "RSYNC: Proxy(" << Get.Host << "): " << proxy << endl;
+
+   // Don't compare now for the same server uri
+   delete server;
+   if ( _config->FindB("Acquire::rsync::apt-support",true) )
+	 server = new RsyncConnExecExt(Get,proxy,RsyncProg);
+   else 
+	 server = new RsyncConnExec(Get,proxy,RsyncProg);
+
+   if ( server->Get(this,Res,File,Itm->DestFile.c_str()) ) {
+	  if ( stat(Itm->DestFile.c_str(), &st)==0 ) {
+		 Res.Size = st.st_size;
+		 // Calculating MD5
+		 //
+		 int fd = open(Itm->DestFile.c_str(), O_RDONLY);
+		 if (fd>=0) {
+			MD5Summation md5;
+			md5.AddFD(fd,st.st_size);
+			Res.MD5Sum = md5.Result();
+			close(fd);
+		 }
+	  }
+	  URIDone(Res);
+	  return true;
+   }
+   Fail(true);
+   return false;
+}
+/*}}}*/
+
+int main(int argc,const char *argv[])
+{ 
+   RsyncMethod Mth;
+   
+   return Mth.Run();
+}
diff --git a/po/de_DE.po b/po/de_DE.po
index a36bfe5..e3f74d5 100644
--- a/po/de_DE.po
+++ b/po/de_DE.po
@@ -1122,7 +1122,7 @@ msgid ""
 "   remove - Remove packages\n"
 "   keep - Keep packages\n"
 "   upgrade - Perform a global upgrade\n"
-"   dist-upgrade - Perform a globla distribution upgrade\n"
+"   dist-upgrade - Perform a global distribution upgrade\n"
 "   build-dep - Install build-dependencies for source packages\n"
 "   update - Retrieve new lists of packages\n"
 "   commit - Apply the changes in the system\n"
@@ -2205,7 +2205,7 @@ msgstr "Index-Dateityp '%s' wird nicht untersttzt"
 
 #: apt-pkg/policy.cc:312
 msgid "Invalid record in the preferences file, no Package header"
-msgstr "Ungltiger Eintrag in preferences Datei, kein Paketkopf"
+msgstr "Ungltiger Eintrag in preferences Datei %s, kein Paketkopf"
 
 #: apt-pkg/policy.cc:334
 #, c-format
diff --git a/po/es_ES.po b/po/es_ES.po
index 100b81f..e5aa892 100644
--- a/po/es_ES.po
+++ b/po/es_ES.po
@@ -1101,7 +1101,7 @@ msgid ""
 "   remove - Remove packages\n"
 "   keep - Keep packages\n"
 "   upgrade - Perform a global upgrade\n"
-"   dist-upgrade - Perform a globla distribution upgrade\n"
+"   dist-upgrade - Perform a global distribution upgrade\n"
 "   build-dep - Install build-dependencies for source packages\n"
 "   update - Retrieve new lists of packages\n"
 "   commit - Apply the changes in the system\n"
diff --git a/po/it_IT.po b/po/it_IT.po
index 850ba33..bad7fc9 100644
--- a/po/it_IT.po
+++ b/po/it_IT.po
@@ -1106,7 +1106,7 @@ msgid ""
 "   remove - Remove packages\n"
 "   keep - Keep packages\n"
 "   upgrade - Perform a global upgrade\n"
-"   dist-upgrade - Perform a globla distribution upgrade\n"
+"   dist-upgrade - Perform a global distribution upgrade\n"
 "   build-dep - Install build-dependencies for source packages\n"
 "   update - Retrieve new lists of packages\n"
 "   commit - Apply the changes in the system\n"
diff --git a/po/ja.po b/po/ja.po
index 4ca8074..4a18835 100644
--- a/po/ja.po
+++ b/po/ja.po
@@ -1204,7 +1204,7 @@ msgid ""
 "   remove - Remove packages\n"
 "   keep - Keep packages\n"
 "   upgrade - Perform a global upgrade\n"
-"   dist-upgrade - Perform a globla distribution upgrade\n"
+"   dist-upgrade - Perform a global distribution upgrade\n"
 "   build-dep - Install build-dependencies for source packages\n"
 "   update - Retrieve new lists of packages\n"
 "   commit - Apply the changes in the system\n"
diff --git a/po/pt_BR.po b/po/pt_BR.po
index 0c26c78..4ea1099 100644
--- a/po/pt_BR.po
+++ b/po/pt_BR.po
@@ -1203,7 +1203,7 @@ msgid ""
 "   remove - Remove packages\n"
 "   keep - Keep packages\n"
 "   upgrade - Perform a global upgrade\n"
-"   dist-upgrade - Perform a globla distribution upgrade\n"
+"   dist-upgrade - Perform a global distribution upgrade\n"
 "   build-dep - Install build-dependencies for source packages\n"
 "   update - Retrieve new lists of packages\n"
 "   commit - Apply the changes in the system\n"
@@ -2192,8 +2192,8 @@ msgid "Index file type '%s' is not supported"
 msgstr "Tipo de arquivo de ndice '%s' no  suportado"
 
 #: apt-pkg/policy.cc:312
-msgid "Invalid record in the preferences file, no Package header"
-msgstr "Registro invlido no arquivo de preferncias, nenhum cabealho Package"
+msgid "Invalid record in the preferences file %s, no Package header"
+msgstr "Registro invlido no arquivo de preferncias %s, nenhum cabealho Package"
 
 #: apt-pkg/policy.cc:334
 #, c-format
diff --git a/po/ru.po b/po/ru.po
index 3f60732..9671d38 100644
--- a/po/ru.po
+++ b/po/ru.po
@@ -789,8 +789,13 @@ msgstr "
 
 #: cmdline/apt-get.cc:1432 cmdline/apt-shell.cc:1507
 #, c-format
-msgid "Reinstallation of %s is not possible, it cannot be downloaded.\n"
-msgstr " %s ,      .\n"
+msgid "Reinstallation of %s is not possible.\n"
+msgstr " %s .\n"
+
+#: cmdline/apt-get.cc:1432 cmdline/apt-shell.cc:1507
+#, c-format
+msgid "Reinstallation of %s-%s is not possible, it cannot be downloaded.\n"
+msgstr " %s-%s ,      .\n"
 
 #: cmdline/apt-get.cc:1440 cmdline/apt-shell.cc:1515
 #, c-format
@@ -1221,7 +1226,7 @@ msgid ""
 "   remove - Remove packages\n"
 "   keep - Keep packages\n"
 "   upgrade - Perform a global upgrade\n"
-"   dist-upgrade - Perform a globla distribution upgrade\n"
+"   dist-upgrade - Perform a global distribution upgrade\n"
 "   build-dep - Install build-dependencies for source packages\n"
 "   update - Retrieve new lists of packages\n"
 "   commit - Apply the changes in the system\n"
diff --git a/test/conf.cc b/test/conf.cc
index 340647b..00eb285 100644
--- a/test/conf.cc
+++ b/test/conf.cc
@@ -1,3 +1,6 @@
+
+#include <config.h>
+
 #include <apt-pkg/configuration.h>
 #include <apt-pkg/error.h>
 
diff --git a/test/extract-control.cc b/test/extract-control.cc
index 29dcbf3..02420de 100644
--- a/test/extract-control.cc
+++ b/test/extract-control.cc
@@ -1,3 +1,6 @@
+
+#include <config.h>
+
 #include <apt-pkg/debfile.h>
 #include <apt-pkg/error.h>
 
diff --git a/test/hash.cc b/test/hash.cc
index 5334c03..60005cc 100644
--- a/test/hash.cc
+++ b/test/hash.cc
@@ -1,3 +1,6 @@
+
+#include <config.h>
+
 #include <apt-pkg/md5.h>
 #include <apt-pkg/sha1.h>
 #include <apt-pkg/strutl.h>
diff --git a/test/mthdcat.cc b/test/mthdcat.cc
index 25d09a3..2961b20 100644
--- a/test/mthdcat.cc
+++ b/test/mthdcat.cc
@@ -2,6 +2,8 @@
    All this does is cat a file into the method without closing the FD when
    the file ends */
 
+#include <config.h>
+
 #include <unistd.h>
 
 int main()
diff --git a/test/rpmver.cc b/test/rpmver.cc
index 9fc807d..a7a8470 100644
--- a/test/rpmver.cc
+++ b/test/rpmver.cc
@@ -1,3 +1,6 @@
+
+#include <config.h>
+
 #include <apt-pkg/debversion.h>
 #include <rpm/rpmio.h>
 #include <rpm/misc.h>
diff --git a/test/scratch.cc b/test/scratch.cc
index d638c70..effe5b9 100644
--- a/test/scratch.cc
+++ b/test/scratch.cc
@@ -1,3 +1,6 @@
+
+#include <config.h>
+
 #include <apt-pkg/dpkgdb.h>
 #include <apt-pkg/debfile.h>
 #include <apt-pkg/error.h>
diff --git a/test/testdeb.cc b/test/testdeb.cc
index 5986621..bf256c1 100644
--- a/test/testdeb.cc
+++ b/test/testdeb.cc
@@ -1,3 +1,6 @@
+
+#include <config.h>
+
 #include <apt-pkg/dirstream.h>
 #include <apt-pkg/debfile.h>
 #include <apt-pkg/error.h>
diff --git a/test/testextract.cc b/test/testextract.cc
index 1c738aa..1ef7e8b 100644
--- a/test/testextract.cc
+++ b/test/testextract.cc
@@ -1,3 +1,6 @@
+
+#include <config.h>
+
 #include <apt-pkg/dpkgdb.h>
 #include <apt-pkg/debfile.h>
 #include <apt-pkg/error.h>
diff --git a/test/uri.cc b/test/uri.cc
index ae9dc9d..ec652de 100644
--- a/test/uri.cc
+++ b/test/uri.cc
@@ -1,3 +1,5 @@
+#include <config.h>
+
 #include <apt-pkg/strutl.h>
 #include <stdio.h>
 
diff --git a/test/versiontest.cc b/test/versiontest.cc
index 5438eb4..174262d 100644
--- a/test/versiontest.cc
+++ b/test/versiontest.cc
@@ -14,6 +14,8 @@
    
    ##################################################################### */
 									/*}}}*/
+#include <config.h>
+
 #include <system.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/version.h>
diff --git a/tools/cached_md5.cc b/tools/cached_md5.cc
index 4df228b..3937be8 100644
--- a/tools/cached_md5.cc
+++ b/tools/cached_md5.cc
@@ -1,12 +1,15 @@
 /*
  * $Id: cached_md5.cc,v 1.4 2003/01/29 13:47:31 niemeyer Exp $
  */
+#include <config.h>
+
 #include <alloca.h>
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <rpm/rpmlib.h>
+#include <rpm/misc.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
@@ -21,8 +24,6 @@
 #include <apt-pkg/configuration.h>
 #include <apt-pkg/md5.h>
 
-#include <config.h>
-
 CachedMD5::CachedMD5(string DirName, string Domain)
 {
    string fname = DirName;
diff --git a/tools/countpkglist.cc b/tools/countpkglist.cc
index 6eb80ba..8252661 100644
--- a/tools/countpkglist.cc
+++ b/tools/countpkglist.cc
@@ -1,3 +1,6 @@
+
+#include <config.h>
+
 #include <stdio.h>
 #include <errno.h>
 #include <string.h>
diff --git a/tools/genpkglist.cc b/tools/genpkglist.cc
index c86ebac..f3ac591 100644
--- a/tools/genpkglist.cc
+++ b/tools/genpkglist.cc
@@ -1,6 +1,8 @@
 /*
  * $Id: genpkglist.cc,v 1.7 2003/01/30 17:18:21 niemeyer Exp $
  */
+#include <config.h>
+
 #include <alloca.h>
 #include <ctype.h>
 #include <dirent.h>
@@ -13,10 +15,13 @@
 #include <sys/types.h>
 #include <unistd.h>
 #include <assert.h>
+#include <locale.h>
 
 #include <map>
 #include <iostream>
 
+#include <tr1/unordered_set>
+
 #include <apt-pkg/error.h>
 #include <apt-pkg/tagfile.h>
 #include <apt-pkg/configuration.h>
@@ -63,7 +68,6 @@ int tags[] =  {
        RPMTAG_OBSOLETEFLAGS,
        RPMTAG_OBSOLETEVERSION,
 
-       RPMTAG_FILEFLAGS
 };
 int numTags = sizeof(tags) / sizeof(int);
 
@@ -76,115 +80,173 @@ typedef struct {
    string url;
 } UpdateInfo;
 
+// path-like Requires
+static
+std::tr1::unordered_set<std::string> reqfiles;
 
-static inline int usefullFile(char *a)
+static
+void addRequiredPath(const char *str)
 {
-   int l = strlen(a);
-   
-   if (strstr(a, "bin") || strstr(a, "/etc") || strncmp(a, "/lib", 4) == 0)
-       return 1;
-   
-   if (l < 3)
-       return 0;
+   reqfiles.insert(str);
+}
+
+static
+bool isRequiredPath(const char *dir, const char *basename)
+{
+   char fullname[strlen(dir) + strlen(basename) + 1];
+   strcpy(fullname, dir);
+   strcat(fullname, basename);
+   if (reqfiles.find(fullname) != reqfiles.end())
+      return true;
+   return false;
+}
+
+// atoms are constant strings with fixed address
+static
+std::tr1::unordered_set<std::string> atoms;
+
+static
+const char *atom(const char *str)
+{
+   return atoms.insert(str).first->c_str();
+}
+
+// memory-efficient way to map path -> packages:
+// dir -> <basename -> pkg+>
+typedef std::multimap<const char * /* basename */, const char * /* pkg */> BPM;
+static
+std::map<const char * /* dir */, BPM> pathOwners;
+
+typedef BPM::const_iterator BPI;
+
+static
+void addPathOwner(const char *dir, const char *basename, const char *pkg)
+{
+   BPM& bp = pathOwners[atom(dir)];
+   basename = atom(basename);
+   pkg = atom(pkg);
+   // check if pkg is already there
+   std::pair<BPI, BPI> ii = bp.equal_range(basename);
+   for (BPI i = ii.first; i != ii.second; ++i) {
+      if (i->second == pkg) {
+         //fprintf(stderr, "already: %s%s %s\n", dir, basename, pkg);
+         return;
+      }
+   }
+   bp.insert(std::make_pair(basename, pkg));
+}
+
+static
+int countPathOwners(const char *dir, const char *basename)
+{
+   BPM& bp = pathOwners[atom(dir)];
+   basename = atom(basename);
+   std::pair<BPI, BPI> ii = bp.equal_range(basename);
+   return std::distance(ii.first, ii.second);
+}
+
+static
+int usefulFile(const char *dir, const char *basename)
+{
+   // standard dirs
+   if (strstr(dir, "/bin/"))
+      return 1;
+   if (strstr(dir, "/sbin/"))
+      return 1;
+   if (strstr(dir, "/etc/"))
+      return 1;
    
-   if (strcmp(a + l - 3, ".so") == 0
-       || strstr(a, ".so."))
-       return 1;
+   // libraries
+   const char *pos = strstr(basename, ".so");
+   if (pos > basename) {
+      int c = pos[3];
+      if (c == '.' || c == '\0')
+         return 1;
+   }
+
+   // if this path is required by any package, it is useful
+   if (isRequiredPath(dir, basename))
+      return 2;
+
+   // if the path is owned by two or more packages, it is still useful
+   if (countPathOwners(dir, basename) > 1)
+      return 3;
+
+   // other paths are not useful
    return 0;
 }
 
 
-static void copyStrippedFileList(Header header, Header newHeader)
+static
+void copyStrippedFileList(Header h1, Header h2)
 {
-   int i;
-   int i1, i2;
-   
-   int type1, type2, type3;
-   int count1, count2, count3;
-   char **dirnames = NULL, **basenames = NULL;
-   int_32 *dirindexes = NULL;
-   char **dnames, **bnames;
-   int_32 *dindexes;
-   int res1, res2, res3;
-   
-#define FREE(a) if (a) free(a);
-   
-   res1 = headerGetEntry(header, RPMTAG_DIRNAMES, &type1, 
-			 (void**)&dirnames, &count1);
-   res2 = headerGetEntry(header, RPMTAG_BASENAMES, &type2, 
-			 (void**)&basenames, &count2);
-   res3 = headerGetEntry(header, RPMTAG_DIRINDEXES, &type3, 
-			 (void**)&dirindexes, &count3);
-   
-   if (res1 != 1 || res2 != 1 || res3 != 1) {
-      FREE(dirnames);
-      FREE(basenames);
+   int_32 bnt = 0, dnt = 0, dit = 0;
+   struct {
+      const char **bn, **dn;
+      int_32 *di;
+      int_32 bnc, dnc, dic;
+   } l1 = {0}, l2 = {0};
+
+   if (!headerGetEntry(h1, RPMTAG_BASENAMES, &bnt, (void**)&l1.bn, &l1.bnc))
+      return;
+   if (!headerGetEntry(h1, RPMTAG_DIRNAMES, &dnt, (void**)&l1.dn, &l1.dnc)) {
+      headerFreeData(l1.bn, (rpmTagType)bnt);
+      return;
+   }
+   if (!headerGetEntry(h1, RPMTAG_DIRINDEXES, &dit, (void**)&l1.di, &l1.dic)) {
+      headerFreeData(l1.bn, (rpmTagType)bnt);
+      headerFreeData(l1.dn, (rpmTagType)dnt);
       return;
    }
 
-   dnames = dirnames;
-   bnames = basenames;
-   dindexes = (int_32*)malloc(sizeof(int_32)*count3);
-   
-   i1 = 0;
-   i2 = 0;
-   for (i = 0; i < count2 ; i++) 
-   {
-      int ok = 0;
-      
-      ok = usefullFile(basenames[i]);
-      if (!ok) 
-	  ok = usefullFile(dirnames[dirindexes[i]]);
-      
-      if (!ok) {
-	 int k = i;
-	 while (dirindexes[i] == dirindexes[k] && i < count2)
-	     i++;
-	 i--;
-	 continue;
+   assert(l1.bnc == l1.dic);
+
+   for (int i = 0; i < l1.bnc; i++) {
+      const char *d = l1.dn[l1.di[i]], *b = l1.bn[i];
+      int ok = usefulFile(d, b);
+      // if (ok > 1) cerr << "useful(" << ok << "): " << d << b << std::endl;
+      if (ok < 1)
+         continue;
+
+      if (!l2.bn) {
+         l2.bn = new const char*[l1.bnc];
+         l2.dn = new const char*[l1.dnc];
+         l2.di = new int_32[l1.dic];
+      }
+
+      l2.bn[l2.bnc++] = b;
+
+      bool has_dir = false;
+      for (int j = 0; j < l2.dnc; j++) {
+         if (l2.dn[j] == d) {
+            l2.di[l2.dic++] = j;
+            has_dir = true;
+            break;
+         }
+      }
+      if (!has_dir) {
+         l2.dn[l2.dnc] = d;
+         l2.di[l2.dic++] = l2.dnc++;
       }
-      
-      
-      if (ok)
-      {
-	 int j;
-	 
-	 bnames[i1] = basenames[i];
-	 for (j = 0; j < i2; j++)
-	 {
-	    if (dnames[j] == dirnames[dirindexes[i]])
-	    {
-	       dindexes[i1] = j;
-	       break;
-	    }
-	 }
-	 if (j == i2) 
-	 {
-	    dnames[i2] = dirnames[dirindexes[i]];
-	    dindexes[i1] = i2;
-	    i2++;
-	 }
-	 assert(i2 <= count1);
-	 i1++;
-      } 
    }
-   
-   if (i1 == 0) {
-      FREE(dirnames);
-      FREE(basenames);
-      FREE(dindexes);
-      return;
+
+   assert(l2.bnc == l2.dic);
+
+   if (l2.bnc > 0) {
+      headerAddEntry(h2, RPMTAG_BASENAMES, bnt, l2.bn, l2.bnc);
+      headerAddEntry(h2, RPMTAG_DIRNAMES, dnt, l2.dn, l2.dnc);
+      headerAddEntry(h2, RPMTAG_DIRINDEXES, dit, l2.di, l2.dic);
    }
-   
-   headerAddEntry(newHeader, RPMTAG_DIRNAMES, type1, dnames, i2);
-   
-   headerAddEntry(newHeader, RPMTAG_BASENAMES, type2, bnames, i1);
-   
-   headerAddEntry(newHeader, RPMTAG_DIRINDEXES, type3, dindexes, i1);
-   
-   FREE(dirnames);
-   FREE(basenames);
-   FREE(dindexes);
+
+   if (l2.bn) {
+      delete[] l2.bn;
+      delete[] l2.dn;
+      delete[] l2.di;
+   }
+
+   headerFreeData(l1.bn, (rpmTagType)bnt);
+   headerFreeData(l1.dn, (rpmTagType)dnt);
+   headerFreeData(l1.di, (rpmTagType)dit);
 }
 
 
@@ -468,7 +530,7 @@ int main(int argc, char ** argv)
    const char *pkgListSuffix = NULL;
    bool pkgListAppend = false;
    
-   putenv("LC_ALL="); // Is this necessary yet (after i18n was supported)?
+   setlocale(LC_ALL, "C");
    for (i = 1; i < argc; i++) {
       if (strcmp(argv[i], "--index") == 0) {
 	 i++;
@@ -598,6 +660,76 @@ int main(int argc, char ** argv)
    int isSource;
 #endif   
 
+   if (!fullFileList) {
+      // ALT: file list cannot be stripped in a dumb manner -- this is going
+      // to produce unmet dependencies.  First pass is required to initialize
+      // certain data structures.
+      for (entry_cur = 0; entry_cur < entry_no; entry_cur++) {
+         if (progressBar) {
+            if (entry_cur)
+               printf("\b\b\b\b\b\b\b\b\b\b");
+            printf(" %04i/%04i", entry_cur + 1, entry_no);
+            fflush(stdout);
+         }
+
+         fd = fdOpen(dirEntries[entry_cur]->d_name, O_RDONLY, 0666);
+         if (!fd)
+            continue;
+         int rc;
+         Header h;
+#if RPM_VERSION >= 0x040100
+         rc = rpmReadPackageFile(ts, fd, dirEntries[entry_cur]->d_name, &h);
+         if (rc == RPMRC_OK || rc == RPMRC_NOTTRUSTED || rc == RPMRC_NOKEY) {
+#else
+         rc = rpmReadPackageHeader(fd, &h, &isSource, NULL, NULL);
+         if (rc == 0) {
+#endif
+            // path-like Requires
+            int_32 reqtype = 0;
+            const char **requires = NULL;
+            int_32 nreq = 0;
+            rc = headerGetEntry(h, RPMTAG_REQUIRENAME, &reqtype, (void**)&requires, &nreq);
+            if (rc == 1) {
+               if (reqtype == RPM_STRING_ARRAY_TYPE) {
+                  int i;
+                  for (i = 0; i < nreq; i++) {
+                     const char *req = requires[i];
+                     if (*req == '/') {
+                        // cerr << dirEntries[entry_cur]->d_name << " requires " << req << endl;
+                        addRequiredPath(req);
+                     }
+                  }
+               }
+            }
+            headerFreeTag(h, requires, (rpmTagType)reqtype);
+
+            // path ownership
+            const char *pkg = NULL;
+            int_32 pkgt = 0;
+            const char **bn = NULL, **dn = NULL;
+            int_32 *di = NULL;
+            int_32 bnt = 0, dnt = 0, dit = 0;
+            int_32 bnc = 0;
+            rc = headerGetEntry(h, RPMTAG_NAME, &pkgt, (void**)&pkg, NULL)
+              && headerGetEntry(h, RPMTAG_BASENAMES, &bnt, (void**)&bn, &bnc)
+              && headerGetEntry(h, RPMTAG_DIRNAMES, &dnt, (void**)&dn, NULL)
+              && headerGetEntry(h, RPMTAG_DIRINDEXES, &dit, (void**)&di, NULL)
+              ;
+            if (rc == 1) {
+               int i;
+               for (i = 0; i < bnc; i++)
+                  addPathOwner(dn[di[i]], bn[i], pkg);
+            }
+            headerFreeTag(h, pkg, (rpmTagType)pkgt);
+            headerFreeTag(h, bn, (rpmTagType)bnt);
+            headerFreeTag(h, dn, (rpmTagType)dnt);
+            headerFreeTag(h, di, (rpmTagType)dit);
+            
+            headerFree(h);
+         }
+         Fclose(fd);
+      }
+   }
    for (entry_cur = 0; entry_cur < entry_no; entry_cur++) {
       struct stat sb;
 
diff --git a/tools/gensrclist.cc b/tools/gensrclist.cc
index 3685789..fd33de8 100644
--- a/tools/gensrclist.cc
+++ b/tools/gensrclist.cc
@@ -1,6 +1,8 @@
 /*
  * $Id: gensrclist.cc,v 1.8 2003/01/30 17:18:21 niemeyer Exp $
  */
+#include <config.h>
+
 #include <alloca.h>
 #include <ctype.h>
 #include <dirent.h>
@@ -13,6 +15,7 @@
 #include <sys/types.h>
 #include <unistd.h>
 #include <assert.h>
+#include <locale.h>
 
 #include <map>
 #include <list>
@@ -159,7 +162,7 @@ int main(int argc, char ** argv)
    const char *srcListSuffix = NULL;
    bool srcListAppend = false;
 
-   putenv("LC_ALL="); // Is this necessary yet (after i18n was supported)?
+   setlocale(LC_ALL, "C");
    for (i = 1; i < argc; i++) {
       if (strcmp(argv[i], "--mapi") == 0) {
 	 mapi = true;
